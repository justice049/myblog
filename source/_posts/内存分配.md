---
title: 爱情呼叫转移，内存分配管理
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/6929537e7f8e1c737822b8f0.jpg
tags: C++内存分配
categories: C++
---


​真是太逊了

一点都不好嘛

在学完环境变量及地址空间

知道虚拟分配和实际物理内存的映射之后感觉更通透了

### C/C++内存分布

```cpp
int globalVar = 1;
static int staticGlobalVar = 1;
void Test()
{
	static int staticVar = 1;
	int localVar = 1;
	int num1[10] = { 1, 2, 3, 4 };
	char char2[] = "abcd";
	const char* pChar3 = "abcd";
	int* ptr1 = (int*)malloc(sizeof(int) * 4);
	int* ptr2 = (int*)calloc(4, sizeof(int));
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	free(ptr1);
	free(ptr3);
}
```

A.栈          B.堆          C.数据段(静态区)          D.代码段(常量区)

globalVar\_\_C\_\_                staticGlobalVar\_\_C\_\_                staticVar\_\_C\_\_                localVar\_\_A\_num1 \_\_A\_\_                char2\_\_A\_\_                \*char2\_\_A\_\_                pChar3\_\_A\_\_\_        \*pChar3\_\_D\_\_                ptr1\_\_A\_\_                \*ptr1\_\_B\_\_

小小C++拿捏拿捏

sizeof(num1) = \_\_40\_\_                sizeof(char2) = \_\_5\_\_                strlen(char2) = \_\_4\_\_  sizeof(pChar3) = \_\_4/8\_\_             strlen(pChar3) = \_\_4\_\_              sizeof(ptr1) = \_\_4/8\_\_

看这是这么多程序内存区域的划分，一个很显然的问题是为什么要进行这样的区域划分呢？

因为方便管理啊，每种数据需求不一样，生命周期不一样

那这些区域哪些我们需要重点关注呢？

堆呗（其他区域都是自动的，动态内存分配是留给程序员自主控制的，申请需释放，否则内存泄漏）

Tips:

> 1. 栈又叫堆栈--非静态局部变量/函数参数/返回值...，栈是向下增长的
> 2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库，用户可使用系统接口创建共享共享内存，做进程间通信
> 3. 堆用于程序运行时动态内存分配，堆是可以上增长的
> 4. 数据段--存储全局数据和静态数据
> 5. 代码段--可执行的代码/只读常量

### C语言中动态内存管理方式

蛙趣好久远，，，看看吧：malloc，calloc，realloc，free这些

```cpp
void Test()
{
	int* p1 = (int*)malloc(sizeof(int));
	free(p1);

	// 1.malloc/calloc/realloc的区别是什么？
	int* p2 = (int*)calloc(4, sizeof(int));
	int* p3 = (int*)realloc(p2, sizeof(int) * 10);

	// 这里需要free(p2)吗？
	free(p3);
}
```

两点点（之前就想着有时间去喝下一点点冰淇淋红茶，结果茶百道古茗霸王茶姬酷酷去，一点点一次没去上我服了哈哈哈哈）面试题：

malloc/calloc/realloc的区别？

calloc和malloc向内存申请一块连续的空间并返回指向这块空间的指针，calloc申请的空间会初始化，malloc不会，realloc多用于调整动态内存开辟出的空间

malloc的实现原理？

我不知道呜呜

### C++中动态内存管理

C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因 此C++又提出了自己的内存管理方式：通过**new**和**delete**操作符进行动态内存管理

#### 内置类型

new/delete操作内置类型时是这样的：

```cpp
void Test()
{
	// 动态申请一个int类型的空间
	int* ptr4 = new int;

	// 动态申请一个int类型的空间并初始化为10
	int* ptr5 = new int(10);

	// 动态申请10个int类型的空间
	int* ptr6 = new int[3];

	delete ptr4;
	delete ptr5;
	delete[] ptr6;
}
```

要是想要十个对象然后初始化就是这样的：

```cpp
int* ptr6 = new int[10] {1, 2, 3, 4, 5};
```

不初始化的初始化成0

用法上变简洁了，还可以控制初始化

申请和释放单个元素的空间，使用new和delete操作符

申请和释放连续的空间，使用 new[]和delete[]

#### 自定义类型

对于自定义类型，它是这样的：

```cpp
class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout << "A():" << this << endl;
	}
	~A()
	{
		cout << "~A():" << this << endl;
	}
private:
	int _a;
};
int main()
{
	A* p1 = (A*)malloc(sizeof(A));
	A* p2 = new A(1);
	free(p1);
	delete p2;
	// 内置类型是几乎是一样的
	int* p3 = (int*)malloc(sizeof(int)); // C
	int* p4 = new int;
	free(p3);
	delete p4;
	A* p5 = (A*)malloc(sizeof(A) * 10);
	A* p6 = new A[10];
	free(p5);
	delete[] p6;
	return 0;
}
```

new/delete 和 malloc/free最大区别是 new/delete对于自定义类型除了开空间还会调用构造函数和析构函数

而且new失败之后会抛出异常，不需要做额外检查

### operator new与operator delete函数

这个还可以重载，是两个全局函数

operator new是对malloc的封装，operator delete是对free的封装

```cpp
if (_callnewh(size) == 0)
     {
         // report no memory
         // 如果申请内存失败了，这里会抛出bad_alloc 类型异常
         static const std::bad_alloc nomem;
         _RAISE(nomem);
     }
 return (p);
}
/*
operator delete: 该函数最终是通过free来释放空间的
*/
void operator delete(void *pUserData)
{
     _CrtMemBlockHeader * pHead;
     RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
     if (pUserData == NULL)
         return;
     _mlock(_HEAP_LOCK);  /* block other threads */
     __TRY
         /* get a pointer to memory block header */
         pHead = pHdr(pUserData);
          /* verify block type */
         _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));
         _free_dbg( pUserData, pHead->nBlockUse );
     __FINALLY
         _munlock(_HEAP_LOCK);  /* release other threads */
     __END_TRY_FINALLY
     return;
}
/*
free的实现
*/
#define   free(p)               _free_dbg(p, _NORMAL_BLOCK)
```

new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过 operator delete全局函数来释放空间

也就是说，new也是malloc

> new = operator new + 构造函数
> 
> operator new = malloc
> 
> delete = 析构 + operator delete

操作符在编译阶段是会转成相应的指令的，最终是call函数地址去执行函数

那么看这段代码，编译器又是怎么知道要几次析构呢？

```cpp
int main()
{
	A* ptr1 = new A;             //operator new + 1次构造
	A* ptr2 = new A[10];		 //operator new[ ] + 10次构造

	delete ptr1;                 //1次析构 + operator delete
	delete[] ptr2;               //?次析构 + operator delete[]

	return 0;
}
```

实际上，我们需要的空间是40个字节，编译器在开辟空间的时候会开辟四十四字节的空间，额外开辟的四个字节的空间是存放对象个数以了解析构的时候要析构多少次

内置类型无需调用析构函数，所以就无需多开四个字节的空间

编译器在优化时候的原则是不干扰正常运行，所以如果我们不显式写析构函数，那它就可能还是不给你开四个字节，因为没有显式写的析构函数，默认的析构函数是由编译器自己生成的，而它啥也不干，所以就也没必要存放对象的个数

搞个逆天的：

```cpp
int main()
{
	int* p1 = new int[10];
	delete p1;
	return 0;
}
```

会发生什么么？

会内存泄漏么？

不会啊，因为底层还是operator new和operator delete

那这个会不会有问题：

```cpp
class A
{
public:
	A();
	~A();

private:

};

A::A()
{
}

A::~A()
{
}

int main()
{
	A* p2 = new A[10];
	delete p2;
	return 0;
}
```

当然！ 会出问题！不是内存泄漏，也不是少调用了九次析构函数，而是


事实上是析构函数

A显示实现了析构函数，所以开辟空间的时候是44个字节，但是由于指针指向首位，而p2不是指向所开辟空间的首位，它是指向首元素，所以也就不能free（free只能free一片，释放位置错了）

所以delete[ ]能帮我们正确调用析构函数

### new和delete的实现原理

如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是： new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL

**new的原理**

> 1. 调用operator new函数申请空间
> 2. 在申请的空间上执行构造函数，完成对象的构造

**delete的原理**

> 1. 在空间上执行析构函数，完成对象中资源的清理工作
> 2. 调用operator delete函数释放对象的空间

**new T[N]的原理**

> 1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请
> 2. 在申请的空间上执行N次构造函数

**delete[]的原理**

> 1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理
> 2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释 放空间

### 定位new表达式(placement-new)

定位new表达式是在**已分配的原始内存空间中调用构造函数初始化一个对象**

使用格式：

**new (place\_address) type**或者**new (place\_address) type(initializer-list)**

place\_address必须是一个指针，initializer-list是类型的初始化列表

使用场景：

定位new表达式在实际中一般是配合内存池使用，因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化

```cpp
class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout << "A():" << this << endl;
	}
	~A()
	{
		cout << "~A():" << this << endl;
	}
private:
	int _a;
};
// 定位new/replacement new
int main()
{
	// p1现在指向的是与A对象相同大小的一段空间，还不能算对象，因为构造函数没有执行
	A* p1 = (A*)malloc(sizeof(A));
	new(p1)A;  			// Tips：如果A类的构造函数有参数时，此处需要传参
	p1->~A();
	free(p1);
	A* p2 = (A*)operator new(sizeof(A));
	new(p2)A(10);
	p2->~A();
	operator delete(p2);
	return 0;
}
```

内存池、线程池、连接池、、、都是池化技术

对于内存池是alloc+定位new调用构造函数初始化，再dealloc+显式调用析构函数销毁

### 常见面试题

#### malloc/free和new/delete的区别

malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放

不同的地方是：

> 1. malloc和free是函数，new和delete是操作符
> 2. malloc申请的空间不会初始化，new可以初始化
> 3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可， 如果是多个对象，[]中指定对象个数即可
> 4. malloc的返回值为void\*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
> 5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常
> 6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成 空间中资源的清理

#### 内存泄漏

什么是内存泄漏？内存泄漏的危害都有什么？

内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况

内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对 该段内存的控制，因而造成了内存的浪费。

内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现 内存泄漏会导致响应越来越慢，最终卡死（占着茅坑不拉屎）

​
