---
title: 时空复杂度
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691d8d143203f7be0017f197.jpg
tags: 时空复杂度
categories: 数据结构
---

#### 算法效率

有的代码很简洁

比如递归求斐波那契数列：

```cpp
long long Fib(int N)
{
	if (N < 3)
	{
		return 1;
	}
	else
	{
		return Fib(N - 1) + Fib(N - 2);
	}
}
```

代码很短，但是短一定好吗?

算法的好坏怎么确定呢？

这个时候就要涉及时间复杂度与空间复杂度了

算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源。

算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。

在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不再需要特别关注一个算法的空间复杂度。

#### 时间复杂度

定义: 算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。

一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有程序跑起来才知道。

但是每个算法都上机测试很麻烦，所以才有了时间复杂度这个分析方式。

一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度，计算时间复杂度时计算的是基本操作的执行次数。
即: 找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度

```cpp
void Func1(int N)
{
	int count = 0;
	for (int i = 0; i < N; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			++count;
		}
	}
	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}
```

计算Func1的时间复杂度？

Func1 执行的基本操作次数

实际中我们计算时间复杂度时，并不一定要计算精确的执行次数，只需要大概执行次数，这里就可以使用大O的渐进表示法

什么是大O的渐进表示法呢？

大O的渐进表示法

大O符号是用于描述函数渐进行为的数学符号。

推导大O阶方法:
1.用常数1取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数。

得到的结果就是大O阶。使用大O的渐进表示法以后，Func1的时间复杂度为:![eq?O%28N%5E2%29](https://latex.csdn.net/eq?O%28N%5E2%29)
我们可以发现，大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。另外有些算法的时间复杂度存在最好、平均和最坏情况，在实际情况中，我们关注最坏情况下的时间复杂度，即关注算法的最坏运行情况。

![eq?O%281%29%20%3C%20O%28log%20n%29%20%3C%20O%28n%29%20%3C%20O%28nlog%20n%29%20%3C%20O%28n%29%20%3C%20O%28n%5E2%29%20%3C%20O%28n%5E3%29%20%3C%20O%28n%21%29%20%3C%20O%28n%5En%29](https://latex.csdn.net/eq?O%281%29%20%3C%20O%28log%20n%29%20%3C%20O%28n%29%20%3C%20O%28nlog%20n%29%20%3C%20O%28n%29%20%3C%20O%28n%5E2%29%20%3C%20O%28n%5E3%29%20%3C%20O%28n%21%29%20%3C%20O%28n%5En%29)

（1）

```cpp
void Func2(int N)
{
	int count = 0;
	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n",count);
}
```

计算Func2的时间复杂度？

用大O渐进法表示（忽略最高阶项常数且只保留最高阶项）

即：O（N）

（2）

```cpp
void Func3(int N, int M)
{
	int count = 0;
	for (int k = 0; k < M; ++k)
	{
		++count;
	}
	for (int k = 0; k < N; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}
```

计算Func3的时间复杂度？

当m和n关系不确定

函数的时间复杂度为O（M+N）

当N远大于M时，时间复杂度为O（N）

当M远大于N时，时间复杂度为 O（M）

当N和M差不多大时，时间复杂度为O(N) or O(M)

（3）

```cpp
void Func4(int N)
{
	int count = 0;
	for (int k = 0; k < 100; ++k)
	{
		++count;
	}
	printf("%d\n",count + N);
}
```

计算Func4的时间复杂度？

该算法的时间复杂度为O(1)
O(1)并不是代表1次，而是常数次

（4）

```cpp
const char* strchr(const char* str, int character)
{
	while (*str)
	{
		if (*str == character)
			return str;
	}
	++str;
}
```

计算strchr的时间复杂度？

时间复杂度是保守的估算，此时该算法最好为O（1），最坏为 O(N)。取最坏O（N）-->（预期管理法）

（5）

```cpp
void Bubblesort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}
```

计算Bubblesort的时间复杂度

冒泡排序时间复杂度为![eq?O%28N%5E2%29](https://latex.csdn.net/eq?O%28N%5E2%29)

第一趟比较：n-1次

第二趟：n-2

第三趟：n-3

...

...

第n-1趟：2

第n趟：1

![eq?F%28N%29%3D%5Cfrac%7BN*%28N-1%29%7D%7B2%7D](https://latex.csdn.net/eq?F%28N%29%3D%5Cfrac%7BN*%28N-1%29%7D%7B2%7D)

等差数列前n项和：（首项+尾项）\*项数/2

计算时间复杂度不要数循环！！

（6）

```cpp
int PartSort1(int* a, int left, int right)
{
	int keyi = left;
	while (left < right)
	{
		while (left < right && a[right] >= a[keyi])
		{
			--right;
		}
		while (left < right && a[left] <= a[keyi])
		{
			++left;
		}
		Swap(&a[left], &a[right]);
	}
	Swap(&a[keyi], &a[left]);
}
```

该算法的时间复杂度就为O（N）

left找大，right找小，合计起来走了n

（7）

```cpp
int Binarysearch(int* a, int n, int x)
{
	assert(a);
	int begin = 0;
	int end = n - 1;
	// [begin，end]: begin和end是左闭右闭区间，因此有=号
	while (begin <= end)
	{
		int mid = begin + ((end - begin) >> 1);
		if (a[mid] < x)
		{
			begin = mid + 1;
		}
		else if (a[mid] > x)
		{
			end = mid - 1;
		}
		else
		{
			return mid;
		}
	}
	return -1;
}
```

计算函数 Binarysearch 的时间复杂度

二分查找，时间复杂度为O（logN），折半查找，最坏情况：![eq?log%7B_2%7Bn%7D%7D](https://latex.csdn.net/eq?log%7B_2%7Bn%7D%7D),把底数2忽略（写logN默认就是以2为底的）当以别的数为底数时，不可简写，写为![eq?log%7B_M%7BN%7D%7D](https://latex.csdn.net/eq?log%7B_M%7BN%7D%7D)

(8)

```cpp
long long Fac(size_t N)
{
	if (0 == N)
		return 1;
	return Fac(N - 1) * N;
}
```

计算它的时间复杂度？

递归计算时是多次函数调用累加

Fac（N）->Fac（N-1）->Fac（N-2）->...->Fac（2）->Fac（1）->Fac（0）

所以最后计算出时间复杂度为：O（N）

（9）

```cpp
long long Fac(size_t N)
{
	if (0 == N)
		return 1;
	for (size_t i = 0; i < N; ++i)
	{
		//
		// 
	}
	return Fac(N - 1) * N;
}
```

![eq?O%28N%5E2%29](https://latex.csdn.net/eq?O%28N%5E2%29)

（10）

```cpp
long long Fib(int N)
{
	if (N < 3)
	{
		return 1;
	}
	else
	{
		return Fib(N - 1) + Fib(N - 2);
	}
}
```

等比数列求和

基本操作递归了2^N次，时间复杂度为![eq?O%282%5EN%29](https://latex.csdn.net/eq?O%282%5EN%29)

题

![](https://pic1.imgdb.cn/item/691d8f453203f7be00180240.png)

解法一思路：

1、先冒泡排序
2、遍历，当前值+1，不等于下一个数字就是下一个数

时间复杂度：![eq?O%28N%5E2%29](https://latex.csdn.net/eq?O%28N%5E2%29)

```cpp
int missingNumber(int* nums, int numsSize)
{
     if (numsSize == 1&&nums[0]==0)
     return 1;
     if (numsSize == 1&&nums[0]==1)
     return 0;
     for(int i=0;i<numsSize-1;i++)
     {
         for(int j=0;j<numsSize-i-1;j++)
         {
             if(nums[j]>nums[j+1])
             {
                 int tmp=nums[j];
                 nums[j]=nums[j+1];
                 nums[j+1]=tmp;
             }
         }
     }
     for(int i=0;i<numsSize;i++)
     {
         if(nums[i]!=i)
         {
             return i;
         }
     }
     return numsSize;
}
```

解法二思路：

用0异或数组每个元素

```cpp
#include<stdio.h>
int missingNumber(int* nums, int numsSize)
{
      int k=0;
      for(int i=0;i<numsSize;i++)
      {
          k^=nums[i];
      }
      for(int i=0;i<=numsSize;i++)
      {
          k^=i;
      }
      printf("%d",k);
      return k;
}
```

时间复杂度：O（N）

解法三思路：

0\~n等差数列公式求和，依次减去数组中的值，结果就是消失的数字

```cpp
int missingNumber(int* nums, int numsSize)
{
	int N = numsSize;
	int sum = ((0 + N) * (N + 1)) / 2;
	for (int i = 0; i < numsSize; ++i)
	{
		sum -= nums[i];
	}
	return sum;
}
```

时间复杂度：O（N）

#### 空间复杂度

空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度。
空间复杂度不是程序占用了多少字节的空间，知道这个也没太大意义，空间复杂度算的是变量的个数。

空间复杂度计算规则跟时间复杂度类似，也使用大O渐进表示法
tips: 函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，空间复杂度主要通过函数在运行时申请的额外空间确定。

（1）

```cpp
void Bubblesort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}
```

空间复杂度：O（1）算法额外开辟的空间：i、end、...，都是常数个

（2）

```cpp
long long* Fibonacci(size_t n)
{
	if (n == 0)
		return NULL;

	long long* fibArray = (long long*)malloc((n + 1) * sizeof(long long));
	fibArray[0] = 0;
	fibArray[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
	}
	return fibArray;
}
```

该算法的空间复杂度：O（N），额外创建了（n+1）个变量

（3）

```cpp
long long Fac(size_t N)
{
	if (N == 0)
		return 1;
	return Fac(N - 1) * N;
}
```

该算法的空间复杂度： O（N）

tips：递归空间复杂度计算，也是空间累加，但是不同的是空间可以重复利用

（4）

```cpp
long long Fib(int N)
{
	if (N < 3)
	{
		return 1;
	}
	else
	{
		return Fib(N - 1) + Fib(N - 2);
	}
}
```

由于空间可以重复利用，所以递归求斐波那契数列的空间复杂度是O（N），即递到最深层后空间销毁，再走别的分支

#### 练习题

（1）

![](https://pic1.imgdb.cn/item/691d8f833203f7be00180254.png)

方法一

```cpp
void reverse(int* nums, int begin, int end)
{
    while(begin < end)
    {
        int tmp = nums[begin];
        nums[begin] = nums[end];
        nums[end] = tmp;

        ++begin;
        --end;
    }
}
void rotate(int* nums, int numsSize, int k){
    if(k > numsSize)
    {
        k %= numsSize;
    }
    reverse(nums, 0, numsSize-1);
    reverse(nums, 0, k-1);
    reverse(nums, k, numsSize-1);
}
```

时间复杂度：O（N），空间复杂度O（1）

方法二

```cpp
void rotate(int* nums, int numsSize, int k)
{
    int newArr[numsSize];
    for (int i = 0; i < numsSize; ++i)
    {
        newArr[(i + k) % numsSize] = nums[i];
    }
    for (int i = 0; i < numsSize; ++i)
    {
        nums[i] = newArr[i];
    }
}
```

时间复杂度： O(N)，空间复杂度： O(N)

（2）

![](https://pic1.imgdb.cn/item/691d8fb53203f7be00180264.png)

方法1

1. 从前往后遍历nums，找到val第一次出现的位置
2. 将val之后的所有元素整体往前搬移，即删除该val
3. nums中有效元素个数减少一个
   循环进行上述操作，直到nums中所有值为val的元素全部删除完

```cpp
int removeElement(int* nums, int numsSize, int val)
{
    while(1)
    {
        // 1. 在nums中找val出现的位置
        int pos = 0;
        for(; pos < numsSize; ++pos)
        {
            if(nums[pos] == val)
            {
                break;
            }
        }
        // 2. 检测是否找到
        if(pos == numsSize)
            break;
        // 3. 找到值为value的元素--将其删除
        for(int j = pos+1; j < numsSize; ++j)
        {
            nums[j-1] = nums[j];
        }
        numsSize--;
    }
    return numsSize;
}
```

方法一时间复杂度:![eq?O%28N%5E2%29](https://latex.csdn.net/eq?O%28N%5E2%29) 空间复杂度:O(1)

方法2

1. 创建一个长度与nums相同的数组temp
2. 遍历nums，将nums中所有与val不同的元素搬移到temp中
3. 将temp中所有元素拷贝回nums中

```cpp
int removeElement(int* nums, int numsSize, int val)
{
    // 1. 申请numSize个元素的新空间
    int* temp = (int*)malloc(sizeof(int)*numsSize);
    if(NULL == temp)
    {
        return 0;
    }
    // 2. 将nums中非value的元素搬移到temp中---尾插到temp中
    int count = 0;
    for(int i = 0; i < numsSize; ++i)
    {
        if(nums[i] != val)
        {
            temp[count] = nums[i];
            ++count;
        }
    }
    // 3. 将temp中删除val之后的所有元素拷贝到nums中
    memcpy(nums, temp, sizeof(int)*count);
    free(temp);
    return count;
}
```

方法二： 时间复杂度: O(N)  空间复杂度: O(N)

优化

由题意得，数组中元素个数最大为100，所以不用动态申请，创建含100个元素的数组即可

1. 创建一个100个元素的整形数组temp
2. 遍历nums，将nums中所有与val不同的元素搬移到temp中
3. 将temp中所有元素拷贝回nums中

```cpp
int removeElement(int* nums, int numsSize, int val)
{
    // 1. 申请numSize个元素的新空间
    int temp[100];
    // 2. 将nums中非value的元素搬移到temp中---尾插到temp中
    int count = 0;
    for(int i = 0; i < numsSize; ++i)
    {
        if(nums[i] != val)
        {
            temp[count] = nums[i];
            ++count;
        }
    }
    // 3. 将temp中删除val之后的所有元素拷贝到nums中
    memcpy(nums, temp, sizeof(int)*count);
    return count;
}
```

方法二优化后： 时间复杂度: O(N)  空间复杂度: O(N)

方法三

原地算法

1.设置一个变量count，用来记录nums中值等于val的元素的个数
2. 遍历nums数组，对于每个元素进行如下操作：
a. 如果num[i]等于val，说明值为val的元素出现了一次，count++
b. 如果nums[i]不等于元素，将nums[i]往前搬移count个位置
因为nums[i]元素之前出现过count个值等于val的元素，已经被删除了
因此次数需要将nums[i]往前搬移
3. 返回删除之后新数组中有效元素个数

```cpp
int removeElement(int* nums, int numsSize, int val)
{
    int count = 0;
    for(int i = 0; i < numsSize; ++i)
    {
        if(nums[i] == val)
        {
            count++;
        }
        else
        {
            nums[i-count] = nums[i];
        }
    }
    return numsSize - count;
}
```

方法三：时间复杂度：O(N)   空间复杂度：O(1)

（3）

![](https://pic1.imgdb.cn/item/691d8fd33203f7be00180276.png)

解法

1. 从后往前遍历数组，将nums1和nums2中的元素逐个比较,将较大的元素往nums1末尾进行搬移
2. 第一步结束后，nums2中可能会有数据没有搬移完，将nums2中剩余的元素逐个搬移到nums1

```cpp
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    // end1、end2：分别标记nums1 和 nums2最后一个有效元素位置
    // end标记nums1的末尾，因为nums1和nums2中的元素从后往前往nums1中存放
    // ，否则会存在数据覆盖
    int end1 = m-1;
    int end2 = n-1;
    int index = m+n-1;
    // 从后往前遍历，将num1或者nums2中较大的元素往num1中end位置搬移
    // 直到将num1或者num2中有效元素全部搬移完
    while(end1 >= 0 && end2 >= 0)
    {
        if(nums1[end1] > nums2[end2])
        {
            nums1[index--] = nums1[end1--];
        }
        else
        {
            nums1[index--] = nums2[end2--];
        }
    }
    // num2中的元素可能没有搬移完，将剩余的元素继续往nums1中搬移
    while(end2 >= 0)
    {
        nums1[index--] = nums2[end2--];
    }
    // num1中剩余元素没有搬移完 ---不用管了，因为num1中剩余的元素本来就在num1中
}
```

该解法： ﻿时间复杂度：O(m+n)，空间复杂度: O(1)

​
