---
title: 类和对象三部曲（one）
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/6929576d7f8e1c737822d9c1.jpg
tags: C++语法
categories: C++
---

​都说C语言是面向过程，分析出求解问题的步骤，通过函数调用来逐步解决问题。

拿洗衣服来举例，C关注的是一个过程

那么C++是什么呢？

**面向对象**的编程语言。

面向对象对象指什么？

象棋里的对象么？找不到男/女朋友就来学C++这样就能找到对象？（码农是这样的，找不到男/女朋友可以自己new一个）


跑偏了，说回面向对象，C++是面向对象的编程语言，从设计理念上区别于C，那么还是以洗衣服为例，C++关注的对象是：**人、衣服、洗衣粉、洗衣机**

洗衣服通过这四个**对象的交互**完成（人无需关注洗衣机如何洗、如何甩干...）

这个思想的理解不急于求成，可以通过实践慢慢体会。。。

## 类

### 引入

在C中结构体只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数：

数据结构中用C方式实现的栈，结构体中只能定义变量

以C++方式实现， 会发现struct中也可以定义函数

```cpp
#include<iostream>
using namespace std;
typedef int DataType;
struct Stack
{
	void Init(size_t capacity)
	{
		_array = (DataType*)malloc(sizeof(DataType) * capacity);
		if (nullptr == _array)
		{
			perror("malloc申请空间失败");
			return;
		}
		_capacity = capacity;
		_size = 0;
	}
	void Push(const DataType& data)
	{
		// 扩容
		_array[_size] = data;
		++_size;
	}
	DataType Top()
	{
		return _array[_size - 1];
	}
	void Destroy()
	{
		if (_array)
		{
			free(_array);
			_array = nullptr;
			_capacity = 0;
			_size = 0;
		}
	}
	DataType* _array;
	size_t _capacity;
	size_t _size;
};
int main()
{
	Stack s;
	s.Init(10);
	s.Push(1);
	s.Push(2);
	s.Push(3);
	cout << s.Top() << endl;
	s.Destroy();
	return 0;
}
```

上面结构体的定义，在C++中更喜欢用class来代替（为了兼容C，怕搞混就弄了个新名字）

### 定义

**class**是​**定义类的关键字**​，**ClassName**是类的​**名字**​，**​{ }​**中是​**类的主体**​（类定义结束时后面分号不能省略）。

类体中内容被称为类的成员：

类中的**变量**被称为类的**属性/成员变量**

类中的**函数**被称为类的**方法/成员函数**

```cpp
class className
{
// 类体：由成员函数和成员变量组成
};
```

在成员变量定义的时候，通常都喜欢在前面带个\_

这是怕搞混：

```cpp
class Date
{
	void Init(int year, int month, int day)
	{
		year = year;    //成员变量和形参区分不开，易混淆
	}
	int year;
	int month;
	int day;
};
```

（不强制，只是约定俗成）一般这样写：

```cpp
class Date
{
	void Init(int year, int month, int day)
	{
		_year = year;  
		_month = month;
		_day = day;
	}
	int _year;
	int _month;
	int _day;
};
```

### 访问

上面的类写完了，想简单的访问一下：

```cpp
class Date
{
	void Init(int year, int month, int day)
	{
		_year = year;  
		_month = month;
		_day = day;
	}
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date date;
	date.Init(2024, 1, 24);
	return 0;
}
```

却发现报了这样的错

这就涉及到访问的知识了。

#### 访问限定符

C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选 择性的将其接口提供给外部的用户使用

访问限定符分为公有、保护、私有：

```cpp
public        //公有
protected     //保护
private       //私有
```

说明：

> 1. public修饰的成员在类外可以直接被访问（类里肯定也可以）
> 2. protected和private修饰的成员在类外不能直接被访问(此处protected和private类似)
> 3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止
> 4. 如果后面没有访问限定符，作用域就到** }** 即类结束。
> 5. class的默认访问权限为private，struct为public(因为struct要兼容C)
> 
> tips：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别

小问题：struct和class有啥子区别呢？

答：C++需要兼容C，所以C++中struct可以当成结构体使用。另外C++中struct还可以用来定义类，和class定义类是一样的（区别是struct定义的类默认访问权限是public，class定义的类默认访问权限是private），另外的，在继承和模板参数列表位置，struct和class也有区别

### 封装

面向对象三大特性：**封装、继承、多态**

在类和对象阶段，主要是研究类的封装特性

问题来了：什么是封装呢？

**封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来 和对象进行交互。**

封装本质上是一种管控，让用户更方便使用类。

例：对于电脑这样一个复杂的设备，提供给用户的就只有开关机键、通过键盘输入，显示器，USB插孔等，让用户和计算机进行交互，完成日常事务。但实际上电脑真正工作的却是CPU、显卡、内存等一些硬件元件，对于计算机使用者而言，不用关心内部核心部件（主板上线路是如何布局的，CPU内部是如 何设计的...），用户只需要知道，怎么开机、怎么通过键盘和鼠标与计算机进行交互即可。

计算机厂商在出厂时，在外部套上壳子，将内部实现细节隐藏起来，仅仅对外提供开关机、鼠标以 及键盘插孔等，让用户可以与计算机进行交互即可。

在C++中实现封装，可以通过类将数据以及操作数据的方法进行有机结合，通过访问权限来隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用

### 作用域

在C++中，类中的成员变量和成员函数是声明和定义分离的，但是我们将类声明在.h文件下，在.cpp文件中访问，会发现：访问不了，找不到

.h下声明：

```cpp
class Stack
{
public:
	void Init(int n=4);
	void Push(int x);
private:
	int* a;
	int top;
	int capacity;
};
```

.cpp下实现：

```cpp
void Init(int n = 4)
{
	a = (int*)malloc(sizeof(int) * n);
	if (a == nullptr)
	{
		perror("malloc申请空间失败");
		return;
	}
	capacity = n;
	top = 0;
}
void Push(int x)
{
	//噜噜啦
	a[top++] = x;
}
```

这和之前学的域的知识就有牵扯了，事关搜索原则：编译器在访问的时候默认只在局部和全局搜索

类本身就是一个域，在指定的时候在函数定义处指定（缺省参数在声明处给）：

```cpp
void Stack::Init(int n)
{
	a = (int*)malloc(sizeof(int) * n);
	if (a == nullptr)
	{
		perror("malloc申请空间失败");
		return;
	}
	capacity = n;
	top = 0;
}
void Stack::Push(int x)
{
	//噜噜啦
	a[top++] = x;
}
```

类定义了一个新的作用域，类的所有成员都在类的作用域中。

在类体外定义成员时，需要使用 **::** **** 作用域操作符指明成员属于哪个类域。

VS他真的我哭死，这小锁头标明的私有也太贴心了


### 实例化

对象实例化：关于声明和定义

请看下面这个：

```cpp
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;  
		_month = month;
		_day = day;
	}
private:
	int _year;       //声明还是定义？
	int _month;
	int _day;    
};
```

这成员变量是声明还是定义？

当然是声明！

判断是声明和定义的一个重要依据是：是否开辟空间

这才是定义：

```cpp
Date d1;
```

定义专业一点的名字叫：**类的实例化 ​**

类是对对象进行描述的，是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它

一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量。

类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间

### 类对象的存储方式

在C中计算结构体，涉及到内存对齐巴拉巴拉

忘了就复习一波：

[冷酷の结构体](https://blog.csdn.net/chestnut_orenge/article/details/135484510 "冷酷の结构体-CSDN博客")那么类的大小怎么计算呢？是否要带上成员函数（即函数指针）呢？

答案是：不包含函数指针

成员函数地址并没有存在对象里面，那怎么说？

这存储方式无非就两种嘛：

对象里即存成员变量，也存成员函数的地址

那这种方式好不好呢？

有一个巨大缺陷：成员函数的地址这样存浪费（每个对象的成员函数的地址都一样，相同的多存造成浪费）

那比较好的方式是怎样的呢？

**对象里只存成员变量，在公共区域存成员函数的地址（代码段）**

那对于空类的情况，编译器怎么计算呢？

对于没有成员变量的类，它们的大小都是1（规定，且没有成员变量的类对象占位，表示它曾经来过）

计算大小也遵循内存对齐，规则和C一样

那么问题来了，内存对齐会浪费空间，为什么还要内存对齐呢？

两个原因：

> 1.读取的时候一次性读4或8字节
> 
> 2.从整数倍开始读

### this指针

请看下面这段代码：

```cpp
class F1
{
public:
	void f2()
	{
		cout << "下一秒我在台北看烟火" << endl;
	}
};
int main()
{
	F1 f1;
	F1* pf1=&f1;
	pf1->f2();

	F1* pf2 = nullptr;
	pf2->f2();

	return 0;
}
```

代码输出的结果是什么？

编译错误、运行时错误？还是正常运行？

居然可以正常运行，那又是为什么捏？

空指针指向也不报错吗？

首先，有箭头不一定有解引用，取决于后面的值在不在指针所指向的空间

而上面的函数不再指针指向的空间，在代码段

虽然有箭头，但是没有解引用，那么具体是怎么调用的呢？

这就涉及到一个知识点了：this指针

所有成员函数默认具有的一个参数：this指针

```cpp
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
    //just声明，声明，访问的不是这个
	int _year;     // 年
	int _month;    // 月
	int _day;      // 日
};
int main()
{
	Date d1, d2;
	d1.Init(2024, 1, 11);
	d2.Init(2024, 2, 22);
	d1.Print();
	d2.Print();
	return 0;
}
```

看这段代码，打印时访问的是同一个函数，但是编译器又是怎么知道该打印哪个的呢？

d1调用的时候打印d1，d2调用的时候打印d2

那这具体应该怎么找呢？

先在局部找，再在全局找（如果指定去指定空间找）

局部找不到，全局也妹有

这个时候牵扯出this指针：

**this指针是成员函数的第一个参数**

也就是说，经过编译器处理后，我们的函数可以看成：

```cpp
void Print(Date* this)
{
	cout << this->_year << "-" << this->_month << "-" << this->_day << endl;
}
```

调用处的处理可以看成：

```cpp
d1.Print(&d1);
d2.Print(&d2);
```

在这里d1调用打印d1，d2调用打印d2就是通过指针实现的

具体来说的话，this指针长这样：

```cpp
Date* const this;
```

不能自己写，但是可以直接用（不要抢亲亲编译器的活）

this指针存在哪里？

堆？栈？静态区？还是常量区？

当然在栈上：因为它是一个形参

它使用寄存器存储传递（频繁使用，访问速度快）

举个栗子：

```cpp
int main()
{
	const int a = 4;
	int j = 0;
	const char* p = "XXXXXXX";
	cout << &a << endl;
	cout << &j << endl;
	cout << &p << endl;
	cout << p << endl;
	cout << (void*)p << endl;
	return 0;
}
```

从这段代码的打印可以看出，常量字符串和上面几个变量的存储位置不同

回到最初的美好：

还是请问这个是为什么：

```cpp
class F1
{
public:
	void f2()
	{
		cout << "下一秒我在台北看烟火" << endl;
	}
};
int main()
{
	F1 f1;
	F1* pf1=&f1;
	pf1->f2();

	F1* pf2 = nullptr;
	pf2->f2();

	return 0;
}
```

为什么能正常打印？

没有解引用，因为该函数没有在p指向的空间，那p有什么作用呢？

答：作为实参传递给this指针

编译不会报错（就是传了个空指针，嘛事妹有）

那这段代码的结果是什么呢？

```cpp
class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->PrintA();
	return 0;
}
```

会崩溃哦

因为对空指针进行了解引用（需要靠指针找到指针指向空间中的内容）

那这段代码能正常运行么？

```cpp
class A
{
public:
	void PrintA()
	{
		cout << "快去炫鸡蛋仔" << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	(*p).PrintA();
	return 0;
}
```

可以正常运行哦

鸡蛋仔真的蛮好吃

道理是一样的，妹有存在对象里就不用解引用啦（编译器只为实际行动买单，它会看这是否有意义）

​
