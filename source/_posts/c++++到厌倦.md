---
title: C++++到厌倦
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691c4afd3203f7be00137cb5.jpg
tags: C++语法
categories: C++
---


​从今天起，我要开始hello，world。

往后更要做到，拳打数据结构，脚踢Linux。

这就是江湖人的风范。

拼搏百天，我要学希普拉斯普拉斯。

C++是在C的基础之上，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式 等。

都说C++是C的补充与延伸，也就是针对C不足的地方进行改进，那么C究竟有哪些不足呢？

请看码：

```cpp
#include <stdio.h>
#include <stdlib.h>
int rand = 10;
int main()
{
	printf("%d\n", rand);
	return 0;
}
```

这样的程序乍一看没有问题，但是会报错，报什么样的错呢？

我们创建了一个全局变量rand，但是在<stdlib.h>的库里包含着rand这个函数，出现了命名冲突（程序员的命名和库出现冲突，库可以是标准库、第三方库等等）

C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决。

在C/C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。

在提命名空间前，先说一个字:域

### 域

请看码：

```cpp
#include <stdio.h>
int x = 0;
int main()
{
	int x = 1;
	printf("%d\n",x);
	return 0;
}
```


输出结果是什么呢？

当然是1。

第一个x是全局变量，第二个x是局部变量。

那么有没有办法访问那个身为全局变量的x呢？

当然可以，只需要加一个奇妙的符号：域作用限定符​**​ （::**​**）**

在C++中，有全局域、局部域，命名空间域和类域。

局部域相当于自己家的菜地，全局域相当于野生菜地，命名空间域相当于邻居的菜地。

不同域可定义同名变量。

编译器在搜索时，秉持着这样的原则：

> 不指定域：
> 
> 1.局部域
> 
> 2.全局域
> 
> 指定域：
> 
> 去指定域搜索
> 
> 若都没有，则报错

想要访问那个全局变量，可以指定域：

```cpp
#include <stdio.h>
namespace wes1
{
	int x = 0;
}
int main()
{
	int x = 1;
	printf("%d\n",wes1::x);
	return 0;
}
```

也可以这样，默认去全局搜索：

```cpp
#include <stdio.h>
int x = 0;
int main()
{
	int x = 1;
	printf("%d\n",::x);
	return 0;
}
```

### namespace

使用命名空间可以将标识符的名称进行本地化， 以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。

#### 命名空间的概念

**命名空间中可以定义变量、函数和类型**

```cpp
namespace wes1
{
	int rand = 10;
	int Add(int left, int right)
	{
		return left + right;
	}
	struct Node
	{
		struct Node* next;
		int val;
	};
}
```

**命名空间可以嵌套**

```cpp
namespace N1
{
int a;
int b;
int Add(int left, int right)
 {
     return left + right;
 }
namespace N2
 {
     int c;
     int d;
     int Sub(int left, int right)
     {
         return left - right;
     }
 }
}
```

**同一个工程中可以出现同名的命名空间，编译器最后会合成于同一个命名空间中**

#### 命名空间的使用

命名空间的使用有三种方式：

1.加命名空间名称及作用域限定符

```cpp
int main()
{
    printf("%d\n", N::a);   //N为命名空间的名称
    return 0;    
}
```

2.使用using将**命名空间中某个成员**引入

```cpp
using N::b;
int main()
{
    printf("%d\n", N::a);
    printf("%d\n", b);
    return 0;    
}
```

3.使用using namespace **命名空间名称**引入

```cpp
using namespace N;
int main()
{
    printf("%d\n", N::a);
    printf("%d\n", b);
    Add(10, 20);
    return 0;    
}
```

不展开也可以访问命名空间中的内容（自己携带零食），展开命名空间相当于随便访问命名空间中的内容（学校允许带零食）

tips：在遇到结构体时，域作用限定符应这样：

```cpp
wes1 :: struct Node phead;
```

而不是这样：

```cpp
struct wes1 :: Node phead;
```

### hello world

认识第一个C++程序吧：

```cpp
#include<iostream>
using namespace std;
int main()
{
	cout << "hello world!" << endl;
	return 0;
}
```

std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中，这行代码：

```cpp
using namespace std;
```

意义是展开std这个命名空间，若没有这句，程序将会报错。（但是展开容易有冲突）

1. 日常练习中，直接using namespace std即可，方便快捷。
2. 项目开发中，使用using namespace std展开，标准库全部暴露出，如果我们定义跟库重名的类型/对象/函数，就存在冲突问题。（代码较多、规模大）

C++输入输出

cout和cin都在iostream这个头文件下，被std包裹（cout和cin分别是ostream和istream类型的对象）

**cout：标准输出对象(控制台)**

**cin：标准输入对象(键盘)**

<<和>>在C中是左移右移的意思，但在C++中，符号进行了复用

> **<<**
> 
> 1.左移
> 
> 2.流插入运算符（很形象，流向对象）
> 
> **>>**
> 
> 1.右移
> 
> 2.流提取运算符

<<可以流很多，可以自动识别类型

码：

```cpp
#include<iostream>
using namespace std;
int main()
{
	int i = 10;
	cout << "hello world!" <<i<<'\n'<< endl;
	return 0;
}
```

tips：endl=endline，相当于换行符

C++用这种方式怎么控制输出精度呢？

C++兼容C，用之前的方法就好。。。

**cin流提取（从键盘提取到变量中，也可以连续提取）**

```cpp
#include<iostream>
using namespace std;
int main()
{
	int i =0;
	int p = 0;
	cin >> i >> p;
	cout << i << p << endl;
	return 0;
}
```

### 缺省参数（默认参数）

#### 使用

缺省参数是声明或定义函数时为函数的参数指定一个缺省值。

在调用该函数时，如果没有指定实 参则采用该形参的缺省值，否则使用指定的实参。

```cpp
#include<iostream>
using namespace std;
void Func(int a = 0)
{
	cout << a << endl;
}
int main()
{
	Func();     // 没有传参时，使用参数的默认值
	Func(10);   // 传参时，使用指定的实参
	return 0;
}
```

#### 分类

##### 全缺省参数

```cpp
void Func(int a = 10, int b = 20, int c = 30)
```

##### 半缺省参数

```cpp
void Func(int a, int b = 10, int c = 20)
```

> tips：
> 
> 1. 半缺省参数必须**从右往左**依次给出，**不能间隔**着给
> 2. 缺省参数不能在函数声明和定义中同时出现（如果声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值，在声明处给编译阶段才不会报错）
> 
> 3.缺省值必须是常量或者全局变量
> 
> 4. C语言不支持（编译器不支持）

### 函数重载

函数重载就是一词多义，是函数的一种特殊情况。

C++允许在**同一作用域**中声明几个功能类似的​**同名函数**​，这些同名函数的​**形参列表(参数个数或类型或类型顺序)不同**​，常用来处理实现功能类似数据类型不同的问题

一个变量可以有多个引用，多个别名

#### 参数类型不同

```cpp
​int Add(int left, int right)
{
	cout << "int Add(int left, int right)" << endl;
	return left + right;
}
double Add(double left, double right)
{
	cout << "double Add(double left, double right)" << endl;
	return left + right;
}
int main()
{
   Add(10, 20);
   Add(10.1, 20.2);
}
```

#### 参数个数不同

```cpp
void f()
{
	cout << "f()" << endl;
}
void f(int a)
{
    cout << "f(int a)" << endl;
}
int main()
{
   f();
   f(10);
}
```

#### 参数类型顺序不同

```cpp
void f(int a, char b)
{
   cout << "f(int a,char b)" << endl;
}
void f(char b, int a)
{
   cout << "f(char b, int a)" << endl;
}
int main()
{
  f(10, 'a');
  f('a', 10);
  return 0;
}
```

C++支持函数重载的原理--**名字修饰**

为什么C++支持函数重载，而C语言不支持呢？

因为C语言在链接时，直接用函数名去找地址，不允许同名函数。

C++引入函数名修饰规则（由 各个编译器自己实现）。

以Linux为例：

在linux下，采用gcc编译完成后，函数名字的修饰不变。

在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息添加到修改后的名字中（g++的函数修饰后变成   \_Z+函数长度 +函数名+类型首字母）。

C++通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。（如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办法区分。）

### 引用

#### 概念

**引用**不是新定义一个变量，而是​**给已存在变量取了一个别名**​，编译器不会为引用变量开辟内存空 间，它和它引用的变量​**共用同一块内存空间**​。

怎么取别名呢？祖师爷又复用了以前的一个符号：**&**

```cpp
void TestRef()
{
    int a = 10;
    int& ra = a;        //定义引用类型
    printf("%p\n", &a);
    printf("%p\n", &ra);
}
```

ra是a的别名，也可以给别名取别名。（抓我鲁迅当然和你周树人有关系）

**tips：引用类型必须和引用实体是同种类型的**

#### **特点**

> 1. 引用在定义时必须**初始化**
> 2. 一个变量**可以有多个引用**
> 3. 引用一旦引用一个实体，再不能引用其他实体

```cpp
void TestRef()
{
   int a = 10;
   // int& ra;   // 编译时出错
   int& ra = a;
   int& rra = a;
   printf("%p %p %p\n", &a, &ra, &rra);  
}
```

#### **常引用**

三种情况都在这啦：

```cpp
void TestConstRef()
{
    const int a = 10;
    //int& ra = a;     // 编译出错，a为常量
    const int& ra = a;

    // int& b = 10;    // 编译出错，b为常量
    const int& b = 10;

    double d = 12.34;
    //int& rd = d;    // 编译出错，类型不同
    const int& rd = d;
}
```

常引用的意思就是取别名，但是不期望修改原来的值（一种变相的对权限的缩小）

临时变量具有常属性，不支持修改，所以这样必错：

```cpp
int a = 1;
int b = 1;
int &c = a + b;
```

在这个阶段它发生的是创建临时变量再进行取别名：

```cpp
double d = 1.1;
const int& ri = d;
```

为什么是创建临时变量呢？

因为我们在学C的时候曾经见过这样一个东西：

```cpp
int i = 97;
char ch = 'a';
if (i == ch)
{
	cout << "相等" << endl;
}
```

i和ch进行比较，ch不做改动，创建一个临时变量进行类型提升后再做比较，是和临时对象比的

**使用场景**

**1.做参数**

在C语言阶段，我们应该都写过这样一个函数：交换两数的值

```cpp
#include<stdio.h>
void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
int main()
{
	int x = 0;
	int y = 1;
	printf("%d  %d\n", x, y);
	Swap(&x, &y);
	printf("%d  %d\n", x, y);
	return 0;
}
```

由于形参是实参的一份临时拷贝，对形参的修改不影响实参，所以我们想要实现交换两数，就必须进行传址调用。

但是在C++引入了引用这个概念后，就会变得方便很多

```cpp
#include<stdio.h>
void Swap(int& a, int& b)
{
	int tmp = a;
	a = b;
	b = tmp;
}
int main()
{
	int x = 0;
	int y = 1;
	printf("%d  %d\n", x, y);
	Swap(x, y);
	printf("%d  %d\n", x, y);
	return 0;
}
```

在这里，&a被看做是x的别名，&b被看做是y的别名。

指针和引用功能类似，近乎重叠，那么引用是否可以完全替代指针呢？

都说C++是在C的基础上做出的完善，而C++的引用，是对指针使用比较复杂的场景进行的替换，让代码更简单易懂，但是不能完全替代指针。

原因：**引用定义后，不可改变指向**

这也就​**不能用引用代替指针完成链表、二叉树等的增加删除等操作**​。

那Java、Python有没有指针呢？

并没有。

那它们是怎么实现链表的呢？

用引用。

好一个以子之矛攻子之盾（bushi）！

其实Java、Python等语言变量定义出来就是引用，并且可以改变指向（和C嘎嘎不一样哦，引用就是不能替代指针！！！指针就是坠吊的！！！）

总结一下引用在做参数方面的杰出贡献：

1.做输出型参数

2.对象比较大，减少拷贝，提高效率

**2.做返回值**

请看这段代码：

```cpp
#include<stdio.h>
int func()
{
	int a = 0;
	return a;
}
int main()
{
	int ret = func();
	return 0;
}
```

在这里函数的返回值是由寄存器带回的，而不是返回a（出作用域就销毁的临时变量）

指针在使用的时候可能会出现野指针，那么引用有没有可能出现野引用呢？

这就是：

```cpp
#include<iostream>
using namespace std;
int& func()
{
	int a = 0;
	return a;
}
int main()
{
	int ret = func();
	cout << ret << endl;
	return 0;
}
```

将a的别名返回了，访问已经还给操作系统的空间，造成了野引用。

结果认为是随机值

由于栈帧空间是可以重复使用的，所以：

```cpp
#include<iostream>
using namespace std;
int& func()
{
	int a = 0;
	return a;
}
int& fx()
{
	int b = 1;
	return b;
}
int main()
{
	int& ret = func();
	cout << ret << endl;
	fx();
	cout << ret << endl;
	return 0;
}
```

这段代码最终结果是

感兴趣的话可以康康：[函数栈帧的创建与销毁-CSDN博客](https://blog.csdn.net/chestnut_orenge/article/details/134173363?spm=1001.2014.3001.5501 "函数栈帧的创建与销毁-CSDN博客")

变量出了函数作用域生命周期结束要销毁（局部变量），不能用引用返回（薛定谔的猫）

若是全局变量、静态变量、堆上的空间等则可以用引用返回。

tips：

以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。

传值和指针在作为传参以及返回值类型上效率相差很大。

#### 引用和指针的区别

> 1. 引用概念上定义一个变量的别名，指针存储一个变量地址
> 2. 引用在定义时必须初始化，指针没有要求
> 3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
> 4. 没有NULL引用，但有NULL指针
> 5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32 位平台下占4个字节)
> 6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
> 7. 有多级指针，但是没有多级引用
> 8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
> 9. 引用比指针使用起来更安全

指针肯定要开辟空间，那引用需不需要开辟空间呢？

引用从语法上不需要开辟空间，但引用的底层实现开辟了空间（引用底层是用指针实现的），语法含义和底层实现背离

明确一点：在汇编层面上，没有引用，都是指针，引用编译后也转换成指针了

### 内联函数

在C语言中，使用函数会有一定开销（创建函数栈帧），如果需要频繁调用一个函数那可能造成的开销就过大，最终导致栈溢出或者怎么怎么，那C是如何解决这个问题的呢？

#### 使用宏

复习一下宏：宏在**预处理**阶段进行​**替换**​，​**不是函数**​，​**没有分号**​，**括号控制优先级**

例：

```cpp
#define ADD(a,b) ((a)+(b))
```

在这个宏定义中，为何要加里面的括号？

因为a或者b可能是表达式，不加可能会由于运算符优先级出错

> 宏优点：
> 
> 1.增强代码的复用性
> 
> 2.提高性能。
> 
> 宏缺点：
> 
> 1.语法复杂、坑多、不容易控制
> 
> 2.不能调试
> 
> 3.没有类型安全的检查

基于这些呢，祖师爷就想着做出一些创作规避这些缺点，内联函数应运而生：

以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调 用建立栈帧的开销，内联函数提升程序运行的效率。

inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会用函数体替换函数调用，在debug版本中内联函数默认是不展开的，在release模式下会展开。若想要在debug模式下展开内联函数，则需要对编译器进行设置

内联也不是完美的，也有缺陷，当函数过大就不适合定义成内联了，会导致代码膨胀，程序变大。

程序变大就变大呗，有啥坏处呢？

举个例子：

墨墨喜欢打王者，她苹果和安卓都有号，双开的她在更新游戏时发现了小小的不同，诶嘿，苹果的这个居然更新的那么快，明明都是一样的内容呀，墨墨开始巴拉巴拉她家网线，但是后面发觉不对劲，网肯定一样啊，一看占用内存，嚯！ios下更新的内容五百多兆，安卓下更新的快到1G了，根网速没关系，只是ios下的那个版本小一些，所以变大肯定不好啦

**缺陷：可能会使目标文件变大**

**优势：少了调用开销，提高程序运行效率**

inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建议：将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、且频繁调用的函数采用inline修饰，否则编译器会忽略inline特性

内联不建议声明和定义分离，分离会导致链接错误，inline被展开，就没有函数地址了，链接就会找不到（嵌套以后，舍去一个预处理阶段，不展开会出问题）

那再顺便墨迹一嘴，为什么要声明和定义分离：

链接错误可能就出现：找不到定义（这是由于函数在使用前没看到声明），但其实还有一种错误：找到一个或多个多重定义的符号，这是咋回事捏？

就比如，你在某个头文件下定义了一个函数，然后有两个源文件都包含了这个头文件，在展开的时候就会生成两个.o文件，从而发生重定义，不构成函数重载，编译器认为你定义的是同名函数

至于这个是干嘛的呢？

```cpp
#pragma once
```

解决头文件包含重复，防止头文件重复展开的！

那假如，我就是想要声明和定义在一起，有没有解决办法捏？

当然有！

用static！！！

还记得static修饰函数怎么样么？

会改变函数的链接属性，只在当前文件可用

还有别的方式：

就是内联：内联不支持声明和定义分离

地址加载到符号表是为了方便调用，而内联函数的底层逻辑是展开，不涉及调用

所以总结一下使用方法就是：

> **小函数用内联**
> 
> **大函数用静态**

### auto关键字

#### 使用

平时我们定义变量这样定义：

```cpp
int i = 0;
int j = i;
```

不过也可以这样定义：

```cpp
int i = 0;
int j = i;
auto m = j;
```

auto的作用是：自动类型识别！ （和引用类似，必须初始化，根据右面推导左面），就像是类型声明时的“占位符”

那它设计出来有什么价值呢？

请看这个：

```cpp
void(*pf)(int, int) = func;
```

这是一种函数指针

玩波花的，可以这样：

```cpp
auto pf = func;
```

让它自己去识别嘛！

在用用auto声明指针类型时，用auto和auto\*没有任何区别，但是用auto声明引用类型时则必须加&

```cpp
int x = 10;
auto a = &x;
auto* b = &x;
auto& c = x;
```

在同一行定义多个变量时，这些变量必须是相同的类型，否则编译器将会报错（编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量）

tips：在C嘎嘎中，可以这样打印类型：

```cpp
int(*pf1)(int, int) = func;
auto pf2 = func;
cout << typeid(pf1).name() << endl;
cout << typeid(pf2).name() << endl;
```

结果：

auto不能做参数，支持做返回值，不能直接用来声明数组

#### 基于范围的for循环

在平常我们一般怎么遍历数组？

这样对吧？

```cpp
int array[] = { 1, 2, 3, 4, 5 };
for (int i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
     array[i] *= 2;
for (int* p = array; p < array + sizeof(array)/ sizeof(array[0]); ++p)
     cout << *p << endl;
```

但是！对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错，因此C++11中引入了基于范围的for循环。

在基于范围的for循环中，循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分表示被迭代的范围：

```cpp
int array[] = { 1, 2, 3, 4, 5 };
for(auto e : array)
     e *= 2;
for(auto e : array)
     cout << e << " ";
```

依次取数组中的值赋值给e，自动迭代，自动判断结束，这时的e相当于数组中值的拷贝（就跟函数形参实参一样，不改变实际值，加个引用就好了）

加引用后：

```cpp
int array[] = { 1, 2, 3, 4, 5 };
for(auto& e : array)
     e *= 2;
for(auto e : array)
     cout << e << " ";
```

tips：和普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环

### 指针空值

在C中我们怎么表示空指针？这样对吧？

```cpp
int* p1 = NULL;
```

那又有什么问题在导致需要在C++中做出改良呢？

请看：

```cpp
void f(int)
{
 cout<<"f(int)"<<endl;
}
void f(int*)
{
 cout<<"f(int*)"<<endl;
}
int main()
{
 f(0);
 f(NULL);
 f((int*)NULL);
 return 0;
}
```

这个程序的本意是想通过NULL调用指针版本的f(int\*)函数，但是别忘了

NULL是个...宏！宏啊！！宏常量！！！

```cpp
#ifndef NULL
#ifdef __cplusplus
#define NULL   0
#else
#define NULL   ((void *)0)
#endif
#endif
```

值是0的宏常量！！和我们这次调用的初衷相悖了！

在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void\*)常量，但是编译器 默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void \*)0

然后呢，就觉得这样使用不太方便，所以在C++11中引入了一个关键字：**nullptr**

所以以后初始化指针就可以用nullptr了

```cpp
int* p = nullptr;
```

为了挺高代码健壮性，以后就都用nullptr啦

​
