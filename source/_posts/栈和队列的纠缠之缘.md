---
title: 栈和队列的纠缠之缘
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691e8f003203f7be00191c4c.png
tags: 栈
categories: 数据结构
---


​## 用队列实现栈

![](https://pic1.imgdb.cn/item/691e8f323203f7be00191c88.png)

一个很有意思的题、和一个很好笑的评论哈哈哈哈：

![](https://pic1.imgdb.cn/item/691e8f593203f7be00191cbd.png)

虽然但是，这题确实有点不顾他人死活的美感，这道题的意思大概就是，让你用队列（不管什么队列）实现栈（最终达到先进后出的效果），那么我们可以将元素出队后入栈：

![](https://pic1.imgdb.cn/item/691e8f723203f7be00191cd4.jpg)

基于队列实现就可以使用两个队列，一个队列用来存放数据，另一个队列用来捯饬数据（也许是捯饬，反正就是折腾数据）。

完整代码：

```cpp
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
#include<stdbool.h>
typedef int QDataType;
typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;
}QNode;
typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
void QueueInit(Queue* pq);
void QueuePush(Queue* pq, QDataType x);
void QueuePop(Queue* pq);
void QueueDestroy(Queue* pq);
QDataType QueueFront(Queue* pq);
QDataType QueueBack(Queue* pq);
bool QueueEmpty(Queue* pq);
int QueueSize(Queue* pq);
void QueueInit(Queue* pq)
{
	assert(pq);
	pq->phead = pq->ptail=NULL;
	pq->size = 0;
}
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newNode = (QNode*)malloc(sizeof(QNode));
	if (newNode == NULL)
	{
		perror("malloc fail");
	}
	newNode->val = x;
	newNode->next = NULL;
	if (pq->ptail == NULL)
	{
		pq->phead= pq->ptail = newNode;
	}
	else
	{
		pq->ptail->next = newNode;
		pq->ptail = newNode;
	}
	pq->size++;
}
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq->size > 0);
	QNode* del = pq->phead;
	pq->phead = pq->phead->next;
	free(del);
	del = NULL;
	if (pq->phead == NULL)
	{
		pq->ptail = NULL;   //防止ptail成为野指针
	}
	pq->size--;
}
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq->phead;
	while (cur)
	{
		QNode* next = cur->next;
		free(cur);
		cur = next;
	}
	pq->size = 0;
	pq->phead = pq->ptail = NULL;
}
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq->phead);
	return pq->phead->val;
}
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq->ptail);
	return pq->ptail->val;
}
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq->phead == NULL;
}
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq->size;
}

typedef struct 
{
    Queue q1;
    Queue q2;
} MyStack;
MyStack* myStackCreate() 
{
    MyStack* pst=(MyStack*)malloc(sizeof(MyStack));
    QueueInit(&pst->q1);
    QueueInit(&pst->q2);
    return pst;
}
void myStackPush(MyStack* obj, int x) 
{
    if(!QueueEmpty(&obj->q1))
    {
        QueuePush(&obj->q1,x);
    }
    else
    {
        QueuePush(&obj->q2,x);
    }
}

int myStackPop(MyStack* obj) 
{
    Queue* emptyq=&obj->q1;
    Queue* notemptyq=&obj->q2;
    if(!QueueEmpty(&obj->q1))
    {
        //防止判断错
        emptyq=&obj->q2;
        notemptyq=&obj->q1;
    }
    //非空队列前N-1个导入空队列，最后一个为栈顶元素
    while(QueueSize(notemptyq)>1)
    {
        QueuePush(emptyq,QueueFront(notemptyq));   //取队头数据出队
        QueuePop(notemptyq);
    }
    int top=QueueFront(notemptyq);
    QueuePop(notemptyq);
    return top;
}
int myStackTop(MyStack* obj) 
{
    if(!QueueEmpty(&obj->q1))
    {
        return QueueBack(&obj->q1);
    }   
    else
    {
        return QueueBack(&obj->q2);
    }
}

bool myStackEmpty(MyStack* obj) 
{
    if(QueueEmpty(&obj->q1)&&QueueEmpty(&obj->q2))
    {
         return true;
    }
    return false;
}
void myStackFree(MyStack* obj) 
{
      QueueDestroy(&obj->q1);
      QueueDestroy(&obj-> q2);
      free(obj);
      obj=NULL;   
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")

## 用栈实现队列

![](https://pic1.imgdb.cn/item/691e8f893203f7be00191cf0.png)

悬着的心总算是④了：

![](https://pic1.imgdb.cn/item/691e8fa33203f7be00191d1b.png)

其实不是很难哈哈，用栈实现队列相对简单，和队列不同，两个队列不会发生顺序的变化，但是两个栈会，只需要反转一次数据即可达成目标。

> 入队：直接将数据存放到栈Push中。
> 
> 出队：1.当栈Pop为空时一键将Push中的数据转移到栈Pop中，Pop出栈。
> 
> ```
> 2.当Pop不为空时则直接出栈Pop。
> ```

代码如下：

```cpp
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
#include<stdbool.h>
typedef int STDataType;
typedef struct Stack
{
	int* a;
	int top;        //栈顶
	int capacity;   //容量
}ST;
void STInit(ST* pst);
void STDestroy(ST* pst);
void STPush(ST* pst,STDataType x);
void STPop(ST* pst);
STDataType STTop(ST* pst);
bool STEmpty(ST* pst);
int STSize(ST* pst);
void STInit(ST* pst)
{
	assert(pst);
	pst->a = NULL;
	pst->capacity = 0;
	pst->top =0;    //指向栈顶元素的下一个元素
	//pst->top = -1;  //指向栈顶元素
}
void STDestroy(ST* pst)
{
	assert(pst);
	free(pst->a);
	pst->a = NULL;
	pst->top = pst->capacity = 0;
}
void STPush(ST* pst,STDataType x)
{
	assert(pst);
	if (pst->top == pst->capacity)
	{
		int newcapacity = pst->capacity == 0 ? 4 : pst->capacity * 2;
		STDataType* tmp = (STDataType*)realloc(pst->a, sizeof(STDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
		}
		pst->a = tmp;
		pst->capacity = newcapacity;
	}
	pst->a[pst->top] = x;
	pst->top++;
}
void STPop(ST* pst)
{
	assert(pst);
	assert(pst->top > 0);
	pst->top--;
}
STDataType STTop(ST* pst)
{
	assert(pst);
	assert(pst->top > 0);
	return pst->a[pst->top - 1];
}
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst->top == 0;
}
int STSize(ST* pst)
{
	assert(pst);
	return pst->top;
}

//以下是模拟实现队列
typedef struct 
{
   ST Push;
   ST Pop;
} MyQueue;
MyQueue* myQueueCreate() 
{
    MyQueue* Q=(MyQueue*)malloc(sizeof(MyQueue));
    STInit(&Q->Push);
    STInit(&Q->Pop);
    return Q;
}
void myQueuePush(MyQueue* obj, int x) 
{
    STPush(&obj->Push,x);
}
int myQueuePop(MyQueue* obj) 
{
    if(!STEmpty(&obj->Pop))
    {
         int a=STTop(&obj->Pop);
         STPop(&obj->Pop);
         return a;
    }
    while(!STEmpty(&obj->Push))
   {
    STPush(&obj->Pop,STTop(&obj->Push));
    STPop(&obj->Push);
   }    
    int a=STTop(&obj->Pop);
    STPop(&obj->Pop);
    return a;
}
int myQueuePeek(MyQueue* obj) 
{
    if(STEmpty(&obj->Pop))
    {
       while(!STEmpty(&obj->Push))
       {     
           STPush(&obj->Pop,STTop(&obj->Push));
           STPop(&obj->Push);
       }
       return STTop(&obj->Pop);
    }
    else
    {
        return STTop(&obj->Pop);
    }
    return STTop(&obj->Push);
}
bool myQueueEmpty(MyQueue* obj) 
{
    if(STEmpty(&obj->Push)&&STEmpty(&obj->Pop))
    {
        return true;
    }    
    return false;
}
void myQueueFree(MyQueue* obj) 
{
    STDestroy(&obj->Pop);
    STDestroy(&obj->Push);
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```

​
