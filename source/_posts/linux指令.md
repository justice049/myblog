---
title: Linux指令
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691d89f33203f7be0017e475.jpg
tags: Linux指令
categories: Linux
---

### 快捷键

| Alt+Enter     | 全屏 |
| --------------- | ------ |
| Ctrl+D        | 退出 |
| Ctrl + Insert | 复制 |
| Shift+Insert  | 粘贴 |

有时指令会出现失控的情况（疯狂打印），Ctrl+C可终止异常命令（一次不行就多按几次），凡是影响你命令行输入的，无脑Ctrl+C就完事了

### pwd

显示当前在linux系统中所处路径

### mkdir

在当前路径下创建一个新的文件夹（目录）

```cpp
mkdir fruit_dir
```

确实新建了一个文件夹呢

创建出的默认是空目录

怎么创建一串路径呢（嵌套的文件夹）？

用mkdir -p就可以了

#### mkdir -p

```cpp
mkdir -p a/b/c
```

目录创建成功

### rmdir

rmdir可以删除空目录（只能用来删除空目录）

如果删除非空目录会报错
### rm

删除东西（目录、可执行程序、文件...）

处于root账号时，删除会执行额外询问（你要把537删了，O.o?）

如果确认要删就输入y（yes），取消删除就输入n（no）

在删除目录时，我们会发现rm删除不了：

这个时候，用rm -r就可以删除了

#### rm -r

递归式删除目录（把所有子目录也都删掉），也会执行额外询问（可以挑着删）

不想让它询问这么多就可以rm -rf强制删除（r:递归，f：强制）

rm -f强制删除，取消删除时询问

我们知道/是linux环境下的根目录，那么假设我们强制删除根目录会发生些什么呢？（别试，试试就逝世）

会发生的就是，系统直接崩。等价代换一下，这就相当于在Windows下格式化C盘

虽然不至于把所有的都删掉（一些正在运行的删不了），但是rm会尽他所能把所有的都删掉，但是云服务器哎，没什么大不了，重装一两分钟就搞定了哎

rm删除就是删除了

所以，删除需谨慎，想好了再用（误删也很常见了）。捅娄子就说吧，大不了被开了（有新手保护期，“老板，我通过实践发现了这个公司的一个漏洞”）

一旦有重要的数据，宁可备份，不可删除

### clear

将显示器上的内容清除（清屏）

是不是觉得和之前的这个代码还挺像的：

```cpp
system("cls");
```

### touch

在当前路径下，创建一个新的普通文件（只能用来创建普通文件）


可以看到确实创建了一个普通文件呢

文件都有自己的属性嘛，那么这串到底是什么意思呢？


方框中的内容，代表文件的创建时间（最近修改时间）就类似CSDN上的这个：


tips：新建一个文件在磁盘上，没写任何东西，它会不会占据磁盘上的空间呢？

我们知道，文件=文件属性+文件内容，文件属性是不是数据呢？当然是！！！是数据就要保存

所以我们对文件的操作分为两种：对属性操作和对内容操作

可以用指令控制文件、编程访问文件

### stat

查看文件更详细的属性（stat是status的缩写，status：身份，地位）


每种文件都有三种时间：Access（访问）、Modify（修改）、Change （改变）

一个文件的ACM时间。是凑巧么？ACM哎！！哦原来是Association for Computing Machinery（美国计算机协会）

### ls

显示查看文件属性（罗列出当前路径下的文件名）

\*（通配符，匹配任意文件名）在linux中指代任意，ls \*就表示罗列出所有文件

在罗列时也可用\*筛选，比如ls data\*1就表示罗列所有以data开头，中间随意，以1结尾的文件

#### ls -l

显示详细属性（展示目录里的内容）

ls -la

显示隐藏文件详细信息（在linux中，以.开头的被称为隐藏文件，Windows中同样有隐藏文件）

查看Windows下隐藏文件：在查看选项中把隐藏的项目勾选即可

任何目录下都会默认具有两个隐藏目录

.用来表示当前路径

..用来表示上一级路径

ls -l -a和ls -a -l也可起到同样的作用（选择顺序不影响）排列组合（-l是显示详细属性、-a是显示隐藏项目）


#### ls -ld

显示目录的属性（单纯ls是显示目录的内容）

### cd

```cpp
cd ice
```

进入指定文件夹

#### cd..

退出当前目录（返回上一级目录），退到最后是/（根目录root）

回退也可以这样：

```cpp
cd ../../../
```

含义：当前路径（c）的上一级路径（b）的上一级路径（a）的上一级路径（ice）

访问任何文件前都需要找到文件，由于路径具有唯一性，我们可以通过路径找到文件

/是linux的路径分隔符 ，\\是Windows的路径分隔符

两个路径分隔符之间一定是一个“文件夹”，路径最末端一定是一个普通文件或文件夹

路径在系统层面标识一个特定文件，路径必须具有唯一性

linux的整个文件目录结构是一棵多叉树，任何一个文件可以有很多子目录，但是只能隶属于一个父目录（一个爹有很多孩子，这些孩子共有一个爹），保证了路径的唯一性。

..方便进行路径的回退：

从根目录开始：绝对路径

```
/usr/lib/test.txt
```

从当前目录下开始：相对路径（假设当前处于bin下）

```
../lib/test.txt
```

那.又有什么作用呢？

.可以确定当前路径下要访问的文件。例如：

已经拥有了一个可执行程序a.out

要让这个可执行程序跑起来，直接输入a.out会显示找不到

系统不会这样找，只能通过路径找到：即./a.out当前路径下的可执行程序a.out

#### cd-

跳转到最近一次所处的路径下（撤回、撤回了一个撤回）方便进行路径切换（可能常用的目录就两个，经常反复横跳）

#### cd \~

进入用户家目录

什么是用户家目录呢？

C:\\Users\\switch ---> windows中的用户默认的家目录
Linux下指定的用户也有自己的家目录
对于root账号：默认家目录是 /root ，root账号也被称为超级管理员账号

对于普通账号：默认家目录是 /home/用户名

tips：任何一个用户，首次登陆，所处的路径都是自己的家目录
Windows系统可以多用户使用，在使用前询问登录哪个账户，是多用户操作系统（但是基本上用不上多用户，个人电脑毕竟就自己用）

Linux也是一款多用户操作系统
我们使用的桌面的本质是文件夹，当我们登陆windows时，它会确认登录用户，再根据用户名，找到用户目录下的”桌面文件夹"，再将桌面文件夹显示形成图形化界面

### tree

以树状形式展示目录

linux目录结构是树状的，可以通过tree命令来使目录呈现更加清晰

但是我们敲的时候发现，怎么还显示不了呢？看看别人家命令，那都能正常跑，显示个没找到命令算是怎么个事？

其实是因为，系统执行一个命令的时候，一定要先找到该命令，系统查找会有指定的搜索路径

我们现在的电脑上没有安装tree命令

怎么安装tree 命令呢？

```cpp
yum -y install tree
```

输入这行命令 ，系统就会安装tree命令（需要是root账户，如果是普通用户，则需要权限，否则会报错）

普通用户输入这行指令：

```cpp
sudo yum -y install tree
```

tips：root账户安装了这个命令，其他用户也可以使用

指令的本质是程序，指令在系统的/user/bin下，安装就是把可执行程序拷贝到系统路径下，卸载就是把可执行程序从系统路径删除

出现这个界面的时候，证明tree命令已经安装完成了

使用一下：查看当前路径下的目录结构

也可以这样用：查看某个目录的目录结构

```cpp
tree fruit_dir
```

### vim

打开文件

可在文件中进行编辑操作（创建新文件）

写个小代码跟世界先打个招呼吧：

```cpp
#include<stdio.h>
int main()
{
   printf("hello world!!");
   printf("hello world!!");
   printf("hello world!!");
   printf("hello world!!");
   
   return 0;
}
```

想退出的话：先按esc进入命令模式，再输入：wq保存并退出

```cpp
:wq
```

写完以后编译：

```cpp
gcc test.c
```

就可以看到当前路径下有一个可执行程序a.out了

```cpp
./a.out
```

就是在当前路径下运行这个文件（小世界也是让我问好上了）

### whoami

查看当前正在使用linux系统的人是谁

### which

打印出所指定的指定名称和在系统所处路径

### alias

给命令起别名（是不是感觉和typedef很像）

例：

```cpp
alias grape='ls -a -l'
```

系统会给一些指令起别名

我们常用的指令ls -l等价于ll

我们会发现，同一个命令有的时候执行带颜色有的时候不带

ls默认给自己带上了--color=auto这样的选项，如果直接ls -l，这个命令就变成了

ls --color=auto -l，所以它带颜色，直接执行可执行程序就不带颜色（没有对应带颜色的选项），若想让它带上颜色，就可以把输入换成

```cpp
/usr/bin/ls --color=auto -l
``` 

所以说平时使用的ls是被别名覆盖过的，ls不是真正的ls，是ls --color=auto

也就是说，指令也可以被删除，删除后就用不了该指令了

### man

访问linux手册页（有一个男人，你不会了就问他）

和我们之前学哪个库函数，不会的话就去官网上查一样（官网：[cplusplus.com](https://cplusplus.com/ "cplusplus.com")）

右上角切换到旧版本下可以查询

换完在这输入就可以了

跑题了，man就像一个手册，也是可以用上下键控制翻动的，退出按q。

虽然说英语挫，但是汉化也不一定好啊，索性直接全英了（不建议汉化）

man也是一条指令，你要是不懂man是啥，也可以man man（我查我自己）

man这个男人，他有很多口袋（查的时候也可以man 1/2.../9 xxx）

```cpp
man 1 rm
```

1.系统中默认的可执行程序（指令）

2.系统调用（linux内核提供的接口）

3.C的库函数

别的不常用。

但是我们一查发现哎嘿，没有

是因为我们购买的云服务器建议用来部署服务（生产环境），所以说把一些不相关的东西删掉了（man手册不全），想要使用安装即可：

```cpp
yum -y install man-pages
```

安装完就可以查了

### cp

拷贝

```cpp
cp src dest
```

拷贝src到dest中（src、dest都可以携带对应的绝对/相对路径拷贝）

dest可以是目录（直接拷贝到目录下）、带路径的文件名（拷贝到指定目录，顺便进行重命名）

含义：拷贝data1到上一级目录下，并把data1重命名为data1plus

如果拷贝目录的话用cp -r

tips：

linux在同一个目录下不允许存在同名文件

#### cp -r

```cpp
cp -r src dest
```

想直接拷贝一连串就

```cpp
cp -rf src dest
```

### mv

1.在指定的目录下，对一个文件或者目录进行重命名

```
mv src newname
```

2.将指定目录下的文件或者目录，”剪切“到指定的目录下

```
mv src path
```

3.将指定目录下的文件或者目录，”剪切“到指定的目录下并重命名

```
mv src path/newname
```

### nano

```
nano 源文件
```

nano是linux下的一个简单记事本（也是需要安装的，老样子）

```cpp
yum install nano
```

打开后直接就能写代码  ，下面有很多指令，写完代码后Ctrl+X就能退出了

还会执行询问（本次修改是否保存和是否取消退出操作）

写完后编译

```
gcc file
```

再运行

```
./a.out
```

程序就可以跑了
### cat

显示文件属性/内容

那我直接cat回车会发生什么？

会发生：直接从键盘中读内容打印在显示器上的情况

就相当于是一直scanf+printf了

拿C++的话说就是一直cin+cout

因为Linux下一切皆文件，所以键盘输入就是对键盘文件进行读取的过程

#### cat -n

所有行加行号显示文件内容

#### cat -b

显示内容并对非空行编号

#### cat -s

不输出多行空行

#### tac

反过来打印

### echo

Linux设计理念：一切皆文件

文件读写真奇妙

普通文件VS显示器（可以把显示器看成是文件）

显示器读方法为空，有写方法

键盘写方法为空，有读方法

对于任何文件，可以读和写。

将显示器当成文件，向显示器打印相当于向显示器文件进行写入

```
echo "hello Linux"
```

相当于向显示器文件进行写入

```
echo "hello Linux" > test.txt
```

相当于本应向显示器文件写入的内容写入到磁盘文件中 ，这个过程被称为**输出重定向（大彻大悟）**

每次重定向，都会从文件开始向文件写入新内容（先清空再写入）

想要**创建一个空文件**或者​**清空一个文件的内容**​，都可以

```
> file
```

想要在原来的文件后进行追加写入，就可以进行追加重定向

```
>> file
```

都说指令是可执行程序嘛，那么我们等价一下，>file这个命令就相当于下面的代码：

```cpp
#include<stdio.h>
int main()
{
   FILE *pf=fopen("log.txt","w");
   if(pf==NULL)
{
   perror("fopen fail");
   return 1;
}
   fclose(pf);
   return 0;
}
```

以写方式打开文件会事先把文件内容先清空

> > 是对文件进行追加

也就相当于下面的代码：

```cpp
#include<stdio.h>
int main()
{
	FILE* pf = fopen("log.txt", "a");   //append 追加
	if (pf == NULL)
	{
		perror("fopen fail");
		return 1;
	}
	fputs("hello world!!", pf);
	fclose(pf);
	return 0;
}
```

所以还是回到最初的起点了：在显示器上打印是向显示器文件进行写入，cat命令就相当于把文件中的内容向显示器文件进行写入（484很清晰）

一个小问题：今天在显示器上显示了个123是向显示器文件写入了数字123还是字符‘1’‘2’‘3’？

当然是向显示器文件写入‘1’‘2’‘3’字符啦！！！

既然有输出重定向，那。。。有没有**输入重定向**呢？

当然有！

```cpp
cat < log.txt
```

这相当于是读数据的时候不再从键盘文件读取，而是改为打开log.txt文件，对log.txt文件内容进行读取，这里的** ****<** **** 被称为**输入重定向（“r”方式打开，读取方向变化）**

总结一下就是：

```cpp
command > filename         //输出重定向
command >> filename        //追加重定向
command < filename         //输入重定向
```

just三个操作，别担心（输入重定向和直接cat原理不一样，甚至区别大了。。。以后再说吧）

### 小插曲\~

都说Linux下一切皆文件嘛。。。那问题来了：为什么要这样？

一个故事：墨墨酱是一个大学生，她的舍友经常和她说一句话：一切皆浮云。墨墨酱期末挂科了。。可怜的墨墨酱没有完成模电的学习，哭哭，但是她想起了舍友的话：一切皆浮云。墨墨酱释然了，墨墨酱在大学想能不能不工作，谁闲的没事给她五百万耍耍，于是乎墨墨酱决定去gogo街区买彩票，芜湖！！！我中了！！五百万到手，墨墨酱欣喜若狂，她又想到：一切皆浮云，墨墨酱平淡了，痛定思痛，墨墨酱要好好学习！墨墨酱潜心读书，皇天不负有心人，墨墨酱拿到了奖学金！！！墨墨酱又想到一切皆浮云，于是墨墨酱戒骄戒躁，谦虚的一步一脚印的走好她的人生路。

一切皆浮云

同理可证，在Linux系统下，一切皆文件的理念广泛适用（有统一法则，可以用一套方式应对所有情况），操作系统跑起来了（前面已经提过，操作系统充当软硬件枢纽的角色）而面对网卡、键盘、磁盘、鼠标多种角色，可以以统一的方式来管理他们（进行文件/设备的访问）

### 实例

好了，都知道了，看个有点吊的东西：

这个东西叫会话窗口（相当于终端），右键单击可以新建终端

新建几个试试水：

在系统下一定会存在一个文件和终端对应，那么到底是哪个文件呢？

来找找看：

```cpp
ls /dev/pts/ -l
```

当终端打开时，最终会被命名为以0、1、2等命名的文件：

那我们怎么分辨是哪个文件呢？

终端也算显示器，所以直接输出重定向：

```cpp
echo "hello Linux" > /dev/pts/1
```

你看，是3

这是以文件形式对终端所对应的文件进行写入，也是Linux设计理念的体现：一切皆文件
是不是很神奇！！！

可以将向文件中写变成向硬件中写，那么如果这个硬件是网卡呢？

是不是最后就是向网络里写数据啦！

（理论上说只要会文件操作，就可以在Linux系统下操作硬件了，嵌入式用了Linux都说好！）

接入皆文件，访问方式皆文件接口

殊途同归

### more

怎么创建大文件呀。。。

```cpp
​i=1; while [ $i -le 100000 ]; do echo "hello Linux $i"; let i++; done   //le相当于<=
```

这是在命令行中写的一个命令行小脚本

一个循环打印，do和done相当于C中的{ }

像上面的运行起来后是直接在屏幕上打印，重定向到文件中就获得了一个大文件：

```cpp
​i=1; while [ $i -le 100000 ]; do echo "hello Linux $i"; let i++; done > big.txt
```

这大文件也是让我创建上了

由于cat直接查大文件会导致刷屏，那么一个很显然的问题：cat不适合查大文件，为了支撑我们查大文本，我们认识一个命令：more

使用more的好处就是可以逐行下翻（一屏打满后逐行下翻，按enter翻）

```cpp
more big.txt
```

输入q退出

```cpp
/xxx
```

/xxx是查找xxx（搜索关键字）

是不是方便了很多！！！！！！

但是其实目的不在这，真正的目的是：介绍less

### less

```cpp
less big.txt
```

less和more差不多，但是也有一点区别：就是less可以随意浏览文件，按 ↑↓ 翻页的那种

是不是很丝滑！！！

为了查日志，我变成狼人模样

嗯。。。此外还有几个查文件的一并说了吧：

### head

head是查看文件头：默认打印前十行

```cpp
head big.txt
```
想打印前x行就：

```cpp
head -x big.txt
```
还有一个是查看文件尾，同head差不多。。。

### tail

```cpp
tail big.txt
```

同样的方法查看x行：

```cpp
tail -x big.txt
```

取头取尾都有了，那假如我不想要头也不想要尾，我想掐头去尾取中间怎么办？(#\`O′)

综合操作罢了：

你先重定向到新文件下（去尾）

```cpp
head -8010 big.txt > tmp.txt
```

再直接（掐头）：

```cpp
tail tmp.txt
```

是不是很简单！！

但是也有一个很显著的缺点：你要创临时文件呀。。。还那么大。。。

不想创建怎么办？

也很简单，直接：

```cpp
head -8010 big.txt | tail 11
```

好哇好哇融汇贯通也是让我蹭上了（按↑↓可以查看历史命令，给我玩一下mc会怎样呢我请问）

这里的 **|** **** 在Linux下被称作管道

**管道有进有出，进行资源传输**

也就是说，管道有入口有出口，进行数据的传输

上一条指令的数据交给传输管道，下一条指令将传输管道内的数据取出（第二条就没有加文件名了，因为直接从管道里拿数据），管道可以级联多条指令：

```cpp
head -8010 big.txt | tail -11 | tac
```

### wc

wc统计文本行数

```cpp
wc -l filename
```

### date

上面通过日志我们已经知道Linux中时间是很重要的，那么有什么关于时间的指令呢？

date就是一条，可以查询时间

```cpp
date
```

但是这样看起来有点难受的呀，能不能直接给我看年月日

可以哇，date支持格式化输出

> %H : 小时(00..23)
> 
> %M : 分钟(00..59)
> 
> %S : 秒(00..61)
> 
> %X : 相当于 %H:%M:%S
> 
> %d : 日 (01..31)
> 
> %m : 月份 (01..12)
> 
> %Y : 完整年份 (0000..9999)
> 
> %F : 相当于 %Y-%m-%d

这样就好了：

```cpp
date +%Y-%m-%d
```

这也是一样的：

```cpp
date +%F
```

tips:计算机领域中时间的重要性！！！

时间非常重要，时间和日志关联很大（大项目的小日记）

拿尹君墨举个例子吧，尹君墨是一家上市公司的小码农，后端组可爱小姐姐一枚，在结束了一天的工作准备**steam启动**的她悲伤的听到电话铃响起，谁这么不长眼给我打电话（好家伙，老板啊，那没事了），一阵猛烈的咆哮响起：尹君墨！！！！你看看你写的狗屎程序！！挂掉了！！！

好吧好吧这狗屁工作我是一天也不想干了麻蛋挂就挂，老子不在乎（鬼扯的，她还不想丢掉亲亲工作呜呜呜）

挂都挂了，她查查吧，首先肯定不能让这继续挂着，先跑起来再说，嗯，程序启动接着跑，她倒要看看这小服务器上的项目什么臭毛病（自己写的史自己查），排查问题肯定不能一步步debug了（程序还在跑呢啊喂），那怎么办？（日志：快来查我快来查我）好吧，查日志，从后往前查（从前往后查你查的过来吗就查）

按照上面的规律，查日志这样查（隔壁码农小姐姐都馋哭了）：

```cpp
tail -50 big.txt | less
```

ww，那再看一个东西吧：时间戳

```cpp
date +%s
```

（应该不陌生，猜数字游戏那见过了，每一次输出都不一样哇）

但也还是说说吧：什么是时间戳？

Unix时间戳（Unix epoch, Unix time, POSIX time / Unix timestamp）是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒

唔，世界上的时间大抵都不一样，弊端就是。。。不利于网络全球化，还是有一个全球统一的时间比较好，于是大家就决定在格林威治开个会，以格林威治为标准，设立了时间戳（随着时间推移不断增长，单增）和时区（可以通过运算统一时间）

时间戳方便进行范围查找

（直接又看不懂）时间戳转化：

```cpp
date +%Y-%m-%d_%H:%M:%S -d @时间戳
```

哎？不是说是从午夜开始的吗？？？

为什么。。八点。。。

嗷嗷嗷！！！时区运算转过来了！！（现在迎面向我们走来的是：北京时间）

### cal

cal是什么？

cal是。。日历！！！

电子老黄历也是搞到了，，，

带手机+拜访学霸沾喜气+平板支撑许愿更易实现

喏，这是root账户下的电子日历：


想看一下出生那年的日历，浅查一下吧：

```cpp
cal 2005
```

这个可以查看当前月、前一个月、后一个月的日历：

```cpp
cal -3
```

### find

find是Linux里的查找指令，选择非常多

看看样例：

```cpp
find / -name test.c
```

这行命令的意思就是：从根目录下开始查找文件名为test.c的文件（关键词检索的魅力）

find是在系统的树形结构目录进行文件查找的（慢一些些）

查找命令：

```cpp
find /usr/bin -name ls
```

find 查找路径 -opt（name） filename

（可以用通配符来更方便的查找文件）

### grep

grep可以在文件中搜索字符串，将找到的行打印出来：

```cpp
grep "xx" big.txt
```

想过滤时显示行号可以：

```cpp
grep -n "xx" big.txt
```

也可以这样反向过滤：不包含xx的行：

```cpp
grep -v "xx" big.txt
```

grep默认进行过滤的时候只会把严格匹配行打印

可以这样以忽略大小写（ignore）：

```cpp
grep -i "xx" big.txt
```

### zip/unzip

打包和压缩：

什么是打包和压缩？

平时下载的各种文件会有各种配置文件（下载的时候只有一个，但是实际上有成百上千个）

下载的是压缩包，要解压拷贝

打包即：把相关的文件都放到一个目录里

压缩：根据算法进行压缩

为什么要打包和压缩？

首先，可以缩小体积（占用资源少，占据磁盘空间小，下载快）

其次，不会轻易丢失文件（打包嘛，J人狂喜了属于是）

那就引出两个命令了：zip、unzip

唔。。没有zip

那就安装一下下吧：

```cpp
yum install -y unzip zip
```

完成叻：

打包格式就很简单：

将test2目录压缩：

```cpp
zip test2.zip test2/*
```

解压到tmp目录：

```cpp
unzip test2.zip -d /tmp
```

但是但是我们会发现一个致命的问题，就是。。。我们貌似打包了个空目录过去：


这个时候回到最初的起点，我们可以发现这文件夹本质也是一棵树哇

所以压缩的时候也要做到递归式压缩：

```cpp
zip -r test2.zip test2
```


解压一下叭：

```cpp
unzip ice.zip
```


打包普通文件＋目录：

```cpp
zip -r ice.zip *
```



小小根目录的所有内容也是被我打包起来了

### tar

打包压缩不仅仅可以使用zip命令哦，还可以用tar：

把dir打包并压缩到test.tgz下

```cpp
tar -czf test.tgz dir  //c--create 创建新压缩包 z--使用压缩算法 f--打包并压缩的文件名称
```

如果想顺便看下打包过程的话就可以：

打包完了，这样解压：

```cpp
tar xvzf test.tgz
```

总结一下吧，关于打包并压缩：

```cpp
zip [-r] name.zip file1 file2 ...
unzip name.zip [-d path]

tar -cvzf name.tgz file1 file2 ...
tar -xvzf name.tgz
```

关于tar的解压到指定目录，命令还有些不一样：

```cpp
tar -xvzf test.tgz -C /home
```

这是解压到home目录下，，，

为什么要打包压缩呀？就是为了网络传输（文件打包不易丢失，但是如果是两个电动车钥匙的话还是分开放比较好）

### sz

我怎么把Linux上的东西打包传到Windows下呢？

用sz就阔以了

```cpp
sz test.tgz
```
但是sz使用之前也要安装一下：

```cpp
yum -y install lrzsz
```

所以sz作用就是：从云服务器上把文件下载到本地

那我怎么从本地传文件到云服务器上呀。。。

### rz

rz+回车后它会默认给你一个弹窗：

可以在Windows本地传输文件到云服务器上

以上操作是基于Xshell进行压缩包的win和Linux进行互传（Linux和Linux间互传当然也可以啦）

### scp

之前学过的cp可以进行拷贝，scp就可以进行网络间拷贝了

这是拷贝dir.tgz压缩包到远端机器root账户中的root目录下：

```cpp
​scp dir.tgz root@远端机器IP:/root
```

确认链接：

输入完root账户的密码就开始拷贝了：

ww这水印是不是很影响观感（我每次已经尽量让它不会挡到字了ww）

### bc

bc是什么？不会是报错吧（愿天堂没有难改的bug）

还没有，安装了再说：

```cpp
yum install -y bc
```

一个小小计算器，也太low了吧。。。（那你别用）

这样用是不是好些：

### uname

uname命令是用来查看当前机器所对应的体系结构的

那。。。所以什么是体系结构啊？

查看计算机关注点：CPU架构、操作系统版本

这里的3.10.0是Linux内核版本，1160.92.1是一些补丁数据，el7是centos realease 7，x86\_64是64位机器（x64），x86是32位机器

唔，来看看吧（你怎么知道我用的是联想拯救者y7000p，i7处理器有着4060显卡的游戏本呀）

你看处理器，是64位操作系统，基于x64的处理器

（32位下的软件在64位下肯定能跑，但是64位的软件不一定能在32位机器上跑）

开发就开发32位的，主打的就是一个通配（兼容老设备）

任务管理器快捷键：Ctrl+Shift+Esc


这就直接打印一下（操作系统版本）版本信息：

```cpp
cat /etc/redhat-release
```

好兄弟我想查一下CPU信息。。。

```cpp
cat /proc/cpuinfo
```
老师我想查内存能不能教教我：

```cpp
cat /proc/meminfo
```

### 热键

热键是什么很热的键吗，还是龙吟的剑？？

就是一些键。。。它比较常用吧大概（快捷键）tab键救我狗命

Ctrl+D直接退出Xshell

| Ctrl+C | 停止当前程序（无脑Ctrl+C就和无脑用溜鬼宝典一样） |
| -------- | -------------------------------------------------- |
| Tab    | 自动补齐（命令补齐）                             |
| Ctrl+R | 输入历史执行命令片段，搜索历史命令               |

### shutdown

shutdown是关机，平时Ctrl+D只是关闭Xshell这个登录软件（断掉与服务器间的链接），但是服务器没有关

```cpp
shutdown -h        //将服务停掉，关机
shutdown -r        //将服务停掉，重启
shutdown -t sec    //-t后面加秒数，过几秒关机
```

还有别的：

```cpp
halt     //关机
reboot   //重启
```

但是。。。云服务器严禁关机。。别瞎折腾。。。知道得了。。。

希望大家都能学好！！！

​
