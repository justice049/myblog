---
title: 五战队列
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691e8dbd3203f7be001919c9.jpg
tags: 队列
categories: 数据结构
---

​什么是队列呢？

下定义：

队列是只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 (First In First Out)的特点。

入队列：进行插入操作的一端称为队尾。

出队列：进行删除操作的一端称为队头。

队列也可以用数组和链表的结构实现，使用链表的结构实现更优。如果使用数组的结构，出队列在数组头，效率比较低。

下面基于不带头单向链表实现队列：

### 声明

声明结点：

```cpp
typedef int QDataType;
typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;
}QNode;
```

由于在后面初始化队列等等操作中，需要改变队头队尾元素，需要用到二级指针，在此处为了方便多声明一个结构体代表整个队列：

```cpp
typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
```

### 初始化

```cpp
void QueueInit(Queue* pq)
{
	assert(pq);
	pq->phead = pq->ptail=NULL;
	pq->size = 0;
}
```

### 入队

```cpp
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newNode = (QNode*)malloc(sizeof(QNode));
	if (newNode == NULL)
	{
		perror("malloc fail");
	}
	newNode->val = x;
	newNode->next = NULL;
	if (pq->ptail == NULL)
	{
		pq->phead= pq->ptail = newNode;
	}
	else
	{
		pq->ptail->next = newNode;
		pq->ptail = newNode;
	}
	pq->size++;
}
```

### 出队

```cpp
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq->size > 0);
	QNode* del = pq->phead;
	pq->phead = pq->phead->next;
	free(del);
	del = NULL;
	if (pq->phead == NULL)
	{
		pq->ptail = NULL;   //防止ptail成为野指针
	}
	pq->size--;
}
```

### 获取队头元素

```cpp
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq->phead);
	return pq->phead->val;
}
```

### 获取队尾元素

```cpp
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq->ptail);
	return pq->ptail->val;
}
```

### 获取队列中有效元素个数

```cpp
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq->size;
}
```

### 队列判空

```cpp
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq->phead == NULL;
}
```

### 销毁队列

```cpp
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq->phead;
	while (cur)
	{
		QNode* next = cur->next;
		free(cur);
		cur = next;
	}
	pq->size = 0;
	pq->phead = pq->ptail = NULL;
}
```

## 完整代码

### Queue.h

```cpp
#pragma once
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
#include<stdbool.h>
typedef int QDataType;
typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;
}QNode;
typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
void QueueInit(Queue* pq);
void QueuePush(Queue* pq, QDataType x);
void QueuePop(Queue* pq);
void QueueDestroy(Queue* pq);
QDataType QueueFront(Queue* pq);
QDataType QueueBack(Queue* pq);
bool QueueEmpty(Queue* pq);
int QueueSize(Queue* pq);
```

### Queue.c

```cpp
#include"Queue.h"
void QueueInit(Queue* pq)
{
	assert(pq);
	pq->phead = pq->ptail=NULL;
	pq->size = 0;
}
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newNode = (QNode*)malloc(sizeof(QNode));
	if (newNode == NULL)
	{
		perror("malloc fail");
	}
	newNode->val = x;
	newNode->next = NULL;
	if (pq->ptail == NULL)
	{
		pq->phead= pq->ptail = newNode;
	}
	else
	{
		pq->ptail->next = newNode;
		pq->ptail = newNode;
	}
	pq->size++;
}
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq->size > 0);
	QNode* del = pq->phead;
	pq->phead = pq->phead->next;
	free(del);
	del = NULL;
	if (pq->phead == NULL)
	{
		pq->ptail = NULL;   //防止ptail成为野指针
	}
	pq->size--;
}
void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq->phead;
	while (cur)
	{
		QNode* next = cur->next;
		free(cur);
		cur = next;
	}
	pq->size = 0;
	pq->phead = pq->ptail = NULL;
}
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq->phead);
	return pq->phead->val;
}
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq->ptail);
	return pq->ptail->val;
}
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq->phead == NULL;
}
int QueueSize(Queue* pq)
{
	assert(pq);
	return pq->size;
}
```

### test.c

```cpp
#include"Queue.h"
int main()
{
	Queue q;
	QueueInit(&q);
	QueuePush(&q, 1);
	QueuePush(&q, 2);
	QueuePush(&q, 3);
	QueuePush(&q, 4);
	QueuePush(&q, 5);
	int size = QueueSize(&q);
	printf("%d\n", size);
	int head = QueueFront(&q);
	printf("%d\n", head);
	int tail = QueueBack(&q);
	printf("%d\n", tail);
	while (!QueueEmpty(&q))
	{
		printf("%d ", QueueFront(&q));
		QueuePop(&q);
	}
	QueueDestroy(&q);
	return 0;
}
```

​
