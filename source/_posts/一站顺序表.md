---
title: 一战顺序表
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691e7e873203f7be0018f9e1.png
tags: 顺序表
categories: 数据结构
---


### 线性表
线性表是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表: 顺序表、链表、栈、队列、字符串...线性表在逻辑上是线性结构，也就说是连续的一条重线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。

链表和顺序表都是线性表的一种


顺序表就像一辆大卡车（和数组差不多），链表就像托马斯小火车

顺序表
概念及结构
顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，，一般情况下采用数组存储。在数组上完成数据的增删查改。

1.静态顺序表:使用定长数组存储元素

```cpp
#define N 7
typedef int SLDataType;
typedef struct SeqList
{
	SLDataType array[N];   //定长数组
	size_t size;           //有效数据个数
}SeqList;
```

2.动态顺序表:使用动态开辟的数组存储

```cpp
typedef struct SeqList
{
	SLDataType* array;  //指向动态开辟的数组
	size_t size;	    //有效数据个数
	size_t capicity;    //容量空间的大小
}SeqList;
//空间不够则增容
```

当线性表的元素总数基本稳定，且很少进行插入和删除操作，但要求以最快的速度存取线性表中的元素时，就可以用顺序表 ，顺序表在使用时一般使用动态顺序表（静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间大小），下面以动态顺序表的实现为例。

定义

```cpp
typedef int SLDataType;
typedef struct SeqList
{
	SLDataType* a;
	SLDataType size;      //有效数据个数
	SLDataType capacity;  //有效容量
}SL;
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")

typedef int的目的是以后要替换不同类型的数据时可以一键替换

### 初始化

声明

```cpp
void Init(SL* psl);
```

实现

```cpp
void Init(SL* psl)
{
	assert(psl);
	psl->a = NULL;
	psl->capacity = 0;
	psl->size = 0;
}
```

使用assert断言以确保传进来的不是空指针，开始时有效数据和容量都为0

### 销毁

声明

```cpp
void SLDestroy(SL* psl);
```

实现

```cpp
void SLDestroy(SL* psl)
{
	assert(psl);
	if (psl->a != NULL)
	{
		free(psl->a);
		psl->a = NULL;
		psl->size = 0;
		psl->capacity = 0;
	}
}
```

free后指针不会再使用，及时置空避免形成野指针

### 打印

声明：

```cpp
void SLPrint(SL* psl);
```

实现：

```cpp
void SLPrint(SL* psl)
{
	assert(psl);
	for (int i = 0; i < psl->size; i++)
	{
		printf("%d ", psl->a[i]);
	}
	printf("\n");
}
```

### 插入

由于插入需要判断当前空间是否足够，不够需要扩容，所以将这个过程封装到一个函数中方便使用

声明：

```cpp
void checkcapacity(SL* psl);
```

实现：

```cpp
void checkcapacity(SL* psl)
{
	assert(psl);
	if (psl->size == psl->capacity)
	{
		int newcapcity = psl->capacity == 0 ? 4 : psl->capacity * 2;
		SLDataType* tmp = (SLDataType*)realloc(psl->a, sizeof(SLDataType) * newcapcity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		psl->a = tmp;
        tmp=NULL;
		psl->capacity = newcapcity;
	}
}
```

由于我们在创建顺序表时没有为其分配空间，所以还需要考虑初始空间为0的情况

创建新指针的原因是要考虑扩容失败的情况，如果扩容失败也要保证先前的空间能够继续使用

#### 头插

声明

```cpp
void SLPushFront(SL* psl, SLDataType x);
```

实现

```cpp
void SLPushFront(SL* psl, SLDataType x)
{
	assert(psl);
	checkcapacity(psl);
	int end = psl->size - 1;
	while (end >= 0)
	{
		psl->a[end+1] = psl->a[end];
		end--;
	}
	psl->a[0] = x;
	psl->size++;
}
```

头插的思路就是将之前存在的数据向后挪移一位

#### 尾插

声明

```cpp
void SLPushBack(SL* psl, SLDataType x);
```

实现

```cpp
void SLPushBack(SL* psl, SLDataType x)
{
	assert(psl);
	checkcapacity(psl);
	psl->a[psl->size] = x;
	psl->size++;
}
```

#### 指定位置插入

声明：

```cpp
void SLInsert(SL* psl, int pos, SLDataType x);
```

实现：

```cpp
void SLInsert(SL* psl, int pos, SLDataType x)
{
	assert(psl);
	assert(pos >= 0 && pos <= psl->size);
	checkcapacity(psl);
	int end = psl->size - 1;
	while (end >= pos)
	{
		psl->a[end + 1] = psl->a[end];
		end--;
	}
	psl->a[pos] = x;
	psl->size++;
}
```

### 删除

#### 尾删

声明：

```cpp
void SLPopBack(SL* psl);
```

实现：

```cpp
void SLPopBack(SL* psl)
{
	assert(psl);
    assert(psl->size>0);
	psl->size--;  //不能free
}
```

tips：

删除是不能free的，内存释放不支持分期付款，free只能把一整个顺序表都free掉，所以删除的思路就是将有效数据-1（以后就算新增数据也可以把它覆盖掉）

#### 头删

声明：

```cpp
void SLPopFront(SL* psl);
```

实现：

```cpp
void SLPopFront(SL* psl)
{
	assert(psl);
	assert(psl->size > 0);
	int begin = 1;
	while (begin < psl->size)
	{
		psl->a[begin - 1] = psl->a[begin];
		begin++;
	}
	psl->size--;
}
```

头删的思路就是后一位的数据覆盖前一位

#### 指定位置删除

声明：

```cpp
void SLErase(SL* psl, int pos);
```

实现：

```cpp
void SLErase(SL* psl, int pos)
{
	assert(psl);
	assert(pos >= 0 && pos < psl->size);
	int begin = pos + 1;
	while (begin < psl->size)
	{
		psl->a[begin - 1] = psl->a[begin];
		begin++;
	}
	psl->size--;
}
```

### 查找

声明：

```cpp
int SLFind(SL* psl, SLDataType x);
```

实现：

```cpp
int SLFind(SL* psl, SLDataType x)
{
	assert(psl);
	for (int i = 0; i < psl->size; i++)
	{
		if (psl->a[i] == x)
		{
			return i;
		}
	}
	return -1;
}
```

### 完整代码

#### SeqList.h

```cpp
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
typedef int SLDataType;
typedef struct SeqList
{
	SLDataType* a;
	SLDataType size;      //有效数据个数
	SLDataType capacity;  //有效容量
}SL;
void Init(SL* psl);
void SLDestroy(SL* psl);
void SLPushBack(SL* psl, SLDataType x);
void SLPushFront(SL* psl, SLDataType x);
void SLPopBack(SL* psl);
void SLPopFront(SL* psl);
void SLPrint(SL* psl);
void checkcapacity(SL* psl);
void SLInsert(SL* psl, int pos, SLDataType x);
void SLErase(SL* psl, int pos);
int SLFind(SL* psl,SLDataType x);
```

#### SeqList.c

```cpp
#include"SeqList.h"
void Init(SL* psl)
{
	assert(psl);
	psl->a = NULL;
	psl->capacity = 0;
	psl->size = 0;
}
void SLDestroy(SL* psl)
{
	assert(psl);
	if (psl->a != NULL)
	{
		free(psl->a);
		psl->a = NULL;
		psl->size = 0;
		psl->capacity = 0;
	}
}
void checkcapacity(SL* psl)
{
	assert(psl);
	if (psl->size == psl->capacity)
	{
		int newcapcity = psl->capacity == 0 ? 4 : psl->capacity * 2;
		SLDataType* tmp = (SLDataType*)realloc(psl->a, sizeof(SLDataType) * newcapcity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		psl->a = tmp;
		psl->capacity = newcapcity;
	}
}
void SLPushBack(SL* psl, SLDataType x)
{
	assert(psl);
	checkcapacity(psl);
	psl->a[psl->size] = x;
	psl->size++;
}
void SLPushFront(SL* psl, SLDataType x)
{
	assert(psl);
	checkcapacity(psl);
	int end = psl->size - 1;
	while (end >= 0)
	{
		psl->a[end+1] = psl->a[end];
		end--;
	}
	psl->a[0] = x;
	psl->size++;
}
void SLPrint(SL* psl)
{
	assert(psl);
	for (int i = 0; i < psl->size; i++)
	{
		printf("%d ", psl->a[i]);
	}
	printf("\n");
}
void SLPopBack(SL* psl)
{
	assert(psl);
    assert(psl->size>0);
	psl->size--;  //不能free
}
void SLPopFront(SL* psl)
{
	assert(psl);
	assert(psl->size > 0);
	int begin = 1;
	while (begin < psl->size)
	{
		psl->a[begin - 1] = psl->a[begin];
		begin++;
	}
	psl->size--;
}
void SLInsert(SL* psl, int pos, SLDataType x)
{
	assert(psl);
	assert(pos >= 0 && pos <= psl->size);
	checkcapacity(psl);
	int end = psl->size - 1;
	while (end >= pos)
	{
		psl->a[end + 1] = psl->a[end];
		end--;
	}
	psl->a[pos] = x;
	psl->size++;
}
void SLErase(SL* psl, int pos)
{
	assert(psl);
	assert(pos >= 0 && pos < psl->size);
	int begin = pos + 1;
	while (begin < psl->size)
	{
		psl->a[begin - 1] = psl->a[begin];
		begin++;
	}
	psl->size--;
}
int SLFind(SL* psl, SLDataType x)
{
	assert(psl);
	for (int i = 0; i < psl->size; i++)
	{
		if (psl->a[i] == x)
		{
			return i;
		}
	}
	return -1;
}
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")

顺序表的问题
1、尾部插入效率还不错，头部或者中间插入删除，需要挪动数据，效率低下。

2、满了以后只能扩容。扩容存在一定空间消耗。（扩容多后空间浪费，扩容少后频繁扩容）

面对需要频繁插入删除的数据，我们可以使用链表（小块小块的空间解决问题）

​
