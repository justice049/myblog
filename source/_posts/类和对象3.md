---
title: 类和对象三部曲（three）
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/6929596cb4e23f08080ab0f9.jpg
tags: C++语法
categories: C++
---

​我喜欢小树森林


接着再说说剩余的类和对象的内容吧

### 构造函数

在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值

```cpp
class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称为对对象中成员变量 的初始化，构造函数体中的语句只能将其称为赋初值，而不能称作初始化。因为初始化只能初始 化一次，而构造函数体内可以多次赋值

#### 初始化列表

初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟 一个放在括号中的初始值或表达式

```cpp
class Date
{
public:
	Date(int year, int month, int day) 
		: _year(year)
		, _month(month)
		, _day(day)
	{}

private:
	int _year;
	int _month;
	int _day;
};
```

那我们为什么要用初始化列表，好奇怪哦，是祖师爷迫不得已吗？

这是为了解决成员变量具有常属性的情况，有些成员必须在定义的时候就初始化，比如const，还有可能出现多次初始化，为了让这些变量都有归途，初始化列表就被创建出来了：

```cpp
class Date
{
public:
	Date(int year, int month, int day) 
		: _n(1)
		,_year(year)
		, _month(month)
		, _day(day)

	{}

private:
	int _year;
	int _month;
	int _day;
	const int _n;
};
```

小米之家虽然没有坐塌，但足够让灵魂歇一歇脚

初始化列表是每个成员变量定义初始化的位置

**有些成员必须走初始化列表：const、&、自定义类型成员(且该类没有默认构造函数时)**

```cpp
class A
{
public:
	A(int a)
		:_a(a)
	{}
private:
	int _a;
};
class B
{
public:
	B(int a, int ref)
		:_aobj(a)
		, _ref(ref)
		, _n(10)
	{}
private:
	A _aobj;  // 没有默认构造函数
	int& _ref;  // 引用
	const int _n; // const 
};
```

开辟空间的这样：

```cpp
class Date
{
public:
	Date(int year, int month, int day, int& x)
		: _n(1)
		, _year(year)
		, _month(month)
		, _day(day)
		, _ref(x)
		, _p((int*)malloc(sizeof(4) * 10))
	{
		if (_p == nullptr)
		{
			perror("malloc fail");
		}
		for (size_t i = 0; i < 10; i++)
		{
			_p[i] = 0;
		}
	}

private:
	int _year;
	int _month;
	int _day;
	const int _n;
	int& _ref;
	int* _p;
};
```

成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关：

```cpp
#include<iostream>
using namespace std;

class A
{
public:
	A(int a)
		:_a1(a)
		, _a2(_a1)
	{}

	void Print() {
		cout << _a1 << " " << _a2 << endl;
	}
private:
	int _a2;
	int _a1;
};
int main() {
	A aa(1);
	aa.Print();
}
```

输出结果是：1        随机值

单参数构造函数支持隐式类型转换：

```cpp
#include<iostream>
using namespace std;

class C
{
public:
	C(int x=0)
		:_x(x)
	{}
private:
	int _x;
};

int main()
{
	C cc1(1);
	C cc2 = 2;
	return 0;
}
```

2构造一个临时对象，再拷贝构造，是内置类型转自定义类型

编译器将这个过程优化成合二为一（同一个表达式的连续步骤的构造）

这样设计的意义是这种操作变得更加便捷：

```cpp
#include<iostream>
using namespace std;

class C
{
public:
	C(int x = 0)
		:_x(x)
	{}
private:
	int _x;
};

class Stack
{
public:
	void Push(const C& c)
	{

	}
};

int main()
{
	//前
	Stack st;
	C cc3(3);
	st.Push(cc3);
	//后
	Stack st;
	st.Push(4);
	return 0;
}
```

#### explicit关键字

如果不想让隐式类型转换发生，就可以：

```cpp
class C
{
public:
	explicit C(int x=0)
		:_x(x)
	{}
private:
	int _x;
};
```

加个关键字explicit

对于多参数的类型这样写是支持的：

```cpp
class A
{
public:
	A(int a1,int a2)
		:_a1(a1)
		,_a2(a2)
	{}
private:
	int _a1;
	int _a2;
};

int main()
{
	A aa1 = { 1,2 };
	const A& aa2 = { 1,2 };
	return 0;
}
```

这样也可以发生隐式类型转换

### Static成员

我们能否实现一个类从而计算出程序内创建了多少个对象呢？

知道调用构造函数以及拷贝构造函数的次数就知道了

```cpp
#include<iostream>
using namespace std;

int n = 0;
class A
{
public:
	A() 
	{
		n++;
	}
	A(const A& aa)
	{
		n++;
	}

private:

};

A func()
{
	A aa;
	return aa;
}

int main()
{
	A aa1;
	A aa2;
	func();
	cout << n << endl;
	return 0;
}
```

按照语法来算的话应该是4个，但是由于不同编译器会做不同程度的优化（一些步骤会简化），所以我的最终运行结果是3（debug和release版本也可能结果不一样）

但是n有没有别人进行操作我们并不知晓，万一谁就悄悄++了一下统计结果不就出错了吗

所以Cpp为我们提供了一个封装：

```cpp
class A
{
public:
	A() 
	{
		n++;
	}
	A(const A& aa)
	{
		n++;
	}

private:
	int n = 0;
};
```

但这样++的并不是同一个n，所以搞成静态的就好了：

```cpp
class A
{
public:
	A() 
	{
		n++;
	}
	A(const A& aa)
	{
		n++;
	}

private:
	static int n;
};
```

静态的不能给缺省值 （因为它不是属于某个对象，而是属于所有对象，属于整个类）

所以它在类内声明，在类外定义

有静态的成员变量，也相应的会有静态的成员函数，静态的成员函数的特点是没有this指针

> 静态成员为所有类对象所共享，不属于某个具体的对象，存放在静态区
> 
> 静态成员变量必须在类外定义，定义时不添加static关键字，类中只是声明
> 
> 类静态成员即可用 类名::静态成员或者对象静态成员来访问
> 
> 静态成员函数没有隐藏的this指针，不能访问任何非静态成员
> 
> 静态成员也是类的成员，受public、protected、private 访问限定符的限制

静态成员函数不能调用非静态成员函数，因为静态成员函数属于类，没有this指针，普通成员函数的调用需要this指针

普通成员函数可以调用静态成员函数，因为静态成员函数放在静态区，整个类和对象都可以访问

### 友元

友元提供了便利也突破了封装（增加耦合度，不宜多用）

友元分为：友元函数和友元类

#### 友元函数

友元函数就和之前的那个差不多，就是有着这样的问题可以用友元来解决：

尝试重载operator，然后发现没办法将operator重载成成员函数，因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以要将operator重载成全局函数。但又会导致类外没办法访问成员，此时就需要友元来解决。operator>>同理：

```cpp
class Date
{
public:
	Date(int year, int month, int day)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
// d1 << cout; -> d1.operator<<(&d1, cout); 不符合常规调用
// 因为成员函数第一个参数一定是隐藏的this，所以d1必须放在<<的左侧
	ostream& operator<<(ostream& _cout)
	{
		_cout << _year << "-" << _month << "-" << _day << endl;
		return _cout;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在 类的内部声明，声明时需要加friend关键字：

```cpp
class Date
{
	friend ostream& operator<<(ostream& _cout, const Date& d);
	friend istream& operator>>(istream& _cin, Date& d);
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
private:
	int _year;
	int _month;
	int _day;
};
ostream& operator<<(ostream& _cout, const Date& d)
{
	_cout << d._year << "-" << d._month << "-" << d._day;
	return _cout;
}
istream& operator>>(istream& _cin, Date& d)
{
	_cin >> d._year;
	_cin >> d._month;
	_cin >> d._day;
	return _cin;
}
int main()
{
	Date d;
	cin >> d;
	cout << d << endl;
	return 0;
}
```

> 友元函数可访问类的私有和保护成员，但不是类的成员函数
> 
> 友元函数不能用const修饰（const修饰的是this指针，友元函数不是成员函数，没有this指针）
> 
> 友元函数可以在类定义的任何地方声明，不受类访问限定符限制
> 
> 一个函数可以是多个类的友元函数
> 
> 友元函数的调用与普通函数的调用原理相同

#### 友元类

友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员

友元关系是单向的，不具有交换性

```cpp
class Time
{
	friend class Date; 
	// 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
public:
	Time(int hour = 0, int minute = 0, int second = 0)
		: _hour(hour)
		, _minute(minute)
		, _second(second)
	{}

private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

	void SetTimeOfDate(int hour, int minute, int second)
	{
		// 直接访问时间类私有的成员变量
		_t._hour = hour;
		_t._minute = minute;
		_t._second = second;
	}

private:
	int _year;
	int _month;
	int _day; 
	Time _t;
};
```

比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行

友元关系不能传递 如果C是B的友元， B是A的友元，则不能说明C时A的友元

友元关系不能继承

### 内部类

如果一个类定义在另一个类的内部，这个类就叫做内部类

内部类是一个独立的类， 它不属于外部类，更不能通过外部类的对象去访问内部类的成员。外部类对内部类没有任何优越的访问权限

tips：内部类就是外部类的友元类，内部类可以通过外部类的对象参数来访问外部类中的所有成员，但是外部类不是内部类的友元。

特性：

> 1. 内部类可以定义在外部类的public、protected、private中
> 2. 内部类可以直接访问外部类中的static成员，不需要外部类的对象/类名
> 3. sizeof(外部类)=外部类，和内部类没有任何关系

类不占用空间，类仅仅是声明

```cpp
class A
{
private:
	static int k;
	int h;
public:
	class B // B天生就是A的友元
	{
	public:
		void foo(const A& a)
		{
			cout << k << endl;//OK
			cout << a.h << endl;//OK
		}
	};
};
int A::k = 1;
int main()
{
	A::B b;
	b.foo(A());

	return 0;
}
```

### 匿名对象

上代码：

```cpp
#include<iostream>
using namespace std;
class A
{
public:
	A(int a = 0)
		:_a(a)
	{
		cout << "A(int a)" << endl; 
	}
	~A()
	{
		cout << "~A()" << endl;
	}
private:
	int _a;
};
class Solution 
{
public:
	int Sum_Solution(int n) 
	{
		//...
		return n;
	}
};
int main()
{
	A aa1;
	// 不能这么定义对象A aa1();，因为编译器无法识别是函数声明，还是对象定义
	// 但是我们可以这么定义匿名对象，匿名对象的特点是不用取名字，
	// 但是他的生命周期只有这一行，我们可以看到下一行他就会自动调用析构函数
	A();
	A aa2(2);
	// 匿名对象在这样的场景下就很好用
	Solution().Sum_Solution(10);
	return 0;
}
```

昙花一现，只开一行

定义对象只为了调用某个函数或者传个参

### 拷贝对象时的编译器优化

在传参和传返回值的过程中，一般编译器会做一些优化，减少对象的拷贝（在一些场景下非常有用）

构造＋拷贝构造直接优化成构造了：

```cpp
class A
{
public:
	A(int a = 0)
		:_a(a)
	{
		cout << "A(int a)" << endl;
	}
	A(const A& aa)
		:_a(aa._a)
	{
		cout << "A(const A& aa)" << endl;
	} A& operator=(const A& aa)
	{
		cout << "A& operator=(const A& aa)" << endl;
		if (this != &aa)
		{
			_a = aa._a;
		}
		return *this;
	}
	~A()
	{
		cout << "~A()" << endl;
	}
private:
	int _a;
};
void f1(A aa)
{}
A f2()
{
	A aa;
	return aa;
}
int main()
{
	// 传值传参
	A aa1;
	f1(aa1);
	cout << endl;
	// 传值返回
	f2();
	cout << endl;
	// 隐式类型，连续构造+拷贝构造->优化为直接构造
	f1(1);
	// 一个表达式中，连续构造+拷贝构造->优化为一个构造
	f1(A(2));
	cout << endl;
	// 一个表达式中，连续拷贝构造+拷贝构造->优化一个拷贝构造
	A aa2 = f2();
	cout << endl;
	// 一个表达式中，连续拷贝构造+赋值重载->无法优化
	aa1 = f2();
	cout << endl;
	return 0;
}
```

编译器在保证正确的前提下进行各种各样的优化

### 理解类和对象

现实生活中的实体计算机并不认识，计算机只认识二进制格式的数据

如果想要让计算机认识现实生活中的实体，用户必须通过某种面向对象的语言，对实体进行描述，然后通过编写程序，创建对象后计算机才可以认识

比如想要让计算机认识洗衣机，就需要：

> 1. 用户先要对现实中洗衣机实体进行抽象---即在人为思想层面对洗衣机进行认识，洗衣机有什 么属性，有那些功能，即对洗衣机进行抽象认知的一个过程
> 2. 经过1之后，在人的头脑中已经对洗衣机有了一个清醒的认识，只不过此时计算机还不清楚，想要让计算机识别人想象中的洗衣机，就需要人通过某种面相对象的语言(比如：C++、 Java、Python等)将洗衣机用类来进行描述，并输入到计算机中
> 3. 经过2之后，在计算机中就有了一个洗衣机类，但是洗衣机类只是站在计算机的角度对洗衣机对象进行描述的，通过洗衣机类，可以实例化出一个个具体的洗衣机对象，此时计算机才能知道洗衣机是什么东西。
> 4. 用户可以借助计算机中洗衣机对象，来模拟现实中的洗衣机实体了。类是对某一类实体(对象)来进行描述的，描述该对象具有哪些属性，哪些方法，描述完成后就形成了一种新的自定义类型，才用该自定义类型实例化具体的对象

### OJ题

![](https://pic1.imgdb.cn/item/692959217f8e1c737822db0c.png)

```cpp
#include <climits>
#include <cmath>
class Sum
{
public:
    Sum()
    {
        _ret+=_i;
        _i++;
    }
    static int GetRet()
    {
        return _ret;
    }
private:
    static int _i;
    static int _ret;
};

int Sum::_i=1;
int Sum::_ret=0;

class Solution {
public:
    int Sum_Solution(int n) 
    {
         Sum a[n];
         return Sum::GetRet();  
    }
};
```

用构造函数代替循环，用构造函数创建n个对象

哎哟我都没写。。。

我不想努力了哥哥

带我走吧

​
