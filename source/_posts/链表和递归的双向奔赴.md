---
title: 链表与递归的双向奔赴
abbrlink: 3eeb
swiper_index: 1
top_group_index: 1
background: "#fff"
cover: https://pic1.imgdb.cn/item/691c4c333203f7be00138497.jpg
tags: 链表
categories: 数据结构
---
![](/img/2025-11-18-15-01-43.png)

​一道题，让我为它提交十八次。

迭代虽好，可是递归看起来更秀哎，官方题解都说呢：递归为我们提供了一种优雅的方式来方向遍历节点。

两个我学起来很闹心的事情结合到一起，双厨狂喜了（我第一次做的时候用的不是递归，不知道哪个聪明小脑瓜用的递归）

递归思路：

使用递归反向迭代节点，同时使用递归函数外的变量向前迭代

计算机如何运行递归函数：在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 n 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况，不是完全适用的，层次过深开销太大。

实现：

```cpp
struct ListNode* frontPointer;
bool recursivelyCheck(struct ListNode* currentNode) 
{
    if (currentNode != NULL) 
    {
        if (!recursivelyCheck(currentNode->next)) 
        {
            return false;
        }
        if (currentNode->val != frontPointer->val) 
        {
            return false;
        }
        frontPointer = frontPointer->next;
    }
    return true;
}

bool isPalindrome(struct ListNode* head) 
{
    frontPointer = head;
    return recursivelyCheck(head);
}
```

力扣的题解真牛波一啊

​
